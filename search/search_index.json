{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Kajson Documentation","text":"<p>Kajson is a powerful drop-in replacement for Python's standard <code>json</code> module that automatically handles complex object serialization, including Pydantic v2 models, datetime objects, and custom types.</p> <ul> <li> <p> Quick Start</p> <p>Get up and running with Kajson in minutes</p> <p> Installation  Quick Start Guide</p> </li> <li> <p> Learn</p> <p>Master Kajson's features with our comprehensive guides</p> <p> User Guide  Examples</p> </li> <li> <p> API Reference</p> <p>Detailed documentation of all Kajson functions and classes</p> <p> API Documentation</p> </li> <li> <p> Contribute</p> <p>Help improve Kajson</p> <p> Contributing Guidelines  GitHub Repository</p> </li> </ul>"},{"location":"#why-kajson","title":"Why Kajson?","text":"<p>Say goodbye to <code>type X is not JSON serializable</code>!</p>"},{"location":"#the-problem-with-standard-json","title":"The Problem with Standard JSON","text":"<pre><code>import json\nfrom datetime import datetime\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    name: str\n    created_at: datetime\n\nuser = User(name=\"Alice\", created_at=datetime.now())\n\n# \u274c Standard json fails\njson.dumps(user)  # TypeError: Object of type User is not JSON serializable\n</code></pre>"},{"location":"#the-kajson-solution","title":"The Kajson Solution","text":"<pre><code>import kajson\n\n# \u2705 Just works!\njson_str = kajson.dumps(user)\nrestored_user = kajson.loads(json_str)\nassert user == restored_user  # Perfect reconstruction!\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd04 Drop-in replacement - Same API as standard <code>json</code> module</li> <li>\ud83d\udc0d Pydantic v2 support - Seamless serialization of Pydantic models</li> <li>\ud83d\udcc5 DateTime handling - Built-in support for date, time, datetime, timedelta</li> <li>\ud83c\udfd7\ufe0f Type preservation - Automatically preserves and reconstructs original types</li> <li>\ud83d\udd0c Extensible - Easy registration of custom encoders/decoders</li> <li>\ud83c\udf81 Batteries included - Common types work out of the box</li> </ul>"},{"location":"#installation","title":"Installation","text":"pippoetryuv <pre><code>pip install kajson\n</code></pre> <pre><code>poetry add kajson\n</code></pre> <pre><code>uv pip install kajson\n</code></pre>"},{"location":"#basic-example","title":"Basic Example","text":"<pre><code>from datetime import datetime, timedelta\nfrom pydantic import BaseModel\nimport kajson\n\nclass Task(BaseModel):\n    name: str\n    created_at: datetime\n    duration: timedelta\n\n# Create and serialize\ntask = Task(\n    name=\"Write documentation\",\n    created_at=datetime.now(),\n    duration=timedelta(hours=2)\n)\n\njson_str = kajson.dumps(task, indent=2)\nprint(json_str)\n\n# Deserialize back\nrestored_task = kajson.loads(json_str)\nassert task == restored_task\n</code></pre>"},{"location":"#used-by-pipelex","title":"Used by Pipelex","text":"<p>This library is used by Pipelex, the open-source language for repeatable AI workflows.</p>"},{"location":"#license","title":"License","text":"<p>Kajson is distributed under the Apache 2.0 License.</p> <p>This project is based on the excellent work from unijson by Bastien Pietropaoli.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>Please see the Code of Conduct for our community guidelines.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v032-2025-10-04","title":"[v0.3.2] - 2025-10-04","text":""},{"location":"changelog/#new-features","title":"\ud83d\ude80 New Features","text":"<ul> <li>GitHub Issue Templates: Added bug report, feature request, and general issue templates to GitHub repository for better issue management</li> <li>API Documentation: Added KajsonManager API reference documentation (Issue #26)</li> </ul>"},{"location":"changelog/#changes","title":"\ud83d\udcdd Changes","text":"<ul> <li>Makefile Updates: Renamed 'doc' targets to 'docs', including 'docs-check' and 'docs-deploy' for better consistency</li> <li>UniversalJSONEncoder Cleanup: Removed unused logger from UniversalJSONEncoder class (Issue #27)</li> <li>Performance Fix: In json_encoder.py, in _get_type_module(), the regex compilation should be at the module level (#28)</li> </ul>"},{"location":"changelog/#security","title":"\ud83d\udd12 Security","text":"<ul> <li>Documentation: Added security considerations section to README regarding deserializing untrusted JSON data</li> </ul>"},{"location":"changelog/#v031-2025-07-10","title":"[v0.3.1] - 2025-07-10","text":"<ul> <li>Fix documentation URL in <code>pyproject.toml</code></li> <li>Add GHA for doc deploy</li> </ul>"},{"location":"changelog/#v030-2025-07-09","title":"[v0.3.0] - 2025-07-09","text":"<ul> <li>Making <code>KajsonManager</code> a proper Singleton using <code>MetaSingleton</code></li> </ul>"},{"location":"changelog/#v024-2025-06-30","title":"[v0.2.4] - 2025-06-30","text":"<ul> <li>Automatic changelog in Github Release</li> </ul>"},{"location":"changelog/#v023-2025-06-26","title":"[v0.2.3] - 2025-06-26","text":"<ul> <li>Better handle enums including in pydantic BaseModels</li> </ul>"},{"location":"changelog/#v022-2025-06-26","title":"[v0.2.2] - 2025-06-26","text":""},{"location":"changelog/#new-features_1","title":"\ud83d\ude80 New Features","text":"<ul> <li>Generic Pydantic Models: Comprehensive support for generic models with type parameters (<code>Container[T]</code>, <code>KeyValueStore[K, V]</code>, etc.) with enhanced class registry that automatically handles generic type resolution and fallback to base classes</li> <li>Cross-Platform DateTime: Enhanced datetime encoding with 4-digit year formatting for better cross-platform compatibility</li> </ul>"},{"location":"changelog/#new-examples","title":"\ud83d\udcda New Examples","text":"<ul> <li><code>ex_15_pydantic_subclass_polymorphism.py</code>: Demonstrates polymorphic APIs, plugin architectures, and mixed collections with preserved subclass types</li> <li><code>ex_16_generic_models.py</code>: Showcases single/multiple type parameters, nested generics, and bounded generic types</li> </ul>"},{"location":"changelog/#core-improvements","title":"\ud83c\udfd7\ufe0f Core Improvements","text":"<ul> <li>Automatic Metadata Handling: Built-in encoders now automatically receive <code>__class__</code> and <code>__module__</code> metadata, simplifying custom encoder implementation</li> <li>Generic Type Resolution: JSON decoder now handles generic class names by intelligently falling back to base classes</li> <li>Timezone Support: Fixed missing timezone encoder/decoder registration for <code>ZoneInfo</code> objects</li> <li>Simplified Encoders: Removed manual metadata from built-in encoders (datetime, date, time, timedelta, timezone)</li> </ul>"},{"location":"changelog/#documentation","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Expanded README: Added compatibility matrix, migration guide, architecture overview, and comprehensive use cases</li> <li>Enhanced API Docs: Updated encoder/decoder documentation with automatic metadata handling examples</li> <li>Examples Documentation: New detailed examples with polymorphism and generic models patterns</li> </ul>"},{"location":"changelog/#testing","title":"\ud83e\uddea Testing","text":"<ul> <li>Integration Tests: Added comprehensive test suites for generic models and subclass polymorphism</li> <li>DateTime Tests: Enhanced datetime/timezone round-trip testing with edge cases and complex structures</li> <li>Class Registry Tests: Improved test coverage for dynamic class scenarios</li> </ul>"},{"location":"changelog/#v021-2025-06-24","title":"[v0.2.1] - 2025-06-24","text":"<ul> <li>Added the last missing example &amp; doc: using the class registry to handle dynamic classes from distributed systems and runtime generation</li> <li>Fixed markdown of overview docs</li> </ul>"},{"location":"changelog/#v020-2025-06-23","title":"[v0.2.0] - 2025-06-23","text":"<ul> <li>Test coverage 100%</li> <li>New integration tests</li> <li>New examples in <code>examples/</code> directory, used as e2e tests</li> <li>Full documentation in <code>docs/</code> directory</li> <li>MkDocs deployed on GitHub pages: https://pipelex.github.io/kajson/ </li> </ul>"},{"location":"changelog/#v016-2025-01-02","title":"[v0.1.6] - 2025-01-02","text":"<ul> <li>Introduced <code>ClassRegistryAbstract</code> (ABC) for dependency injection of ClassRegistry</li> <li>Added <code>KajsonManager</code> for better lifecycle management</li> <li>Changed default Python version to 3.11 (still requires Python &gt;=3.9)</li> <li>Updated Pydantic dependency from exact version <code>==2.10.6</code> to minimum version <code>&gt;=2.10.6</code></li> <li>Code cleanup and removal of unused components, most notably the <code>sandbox_manager</code></li> </ul>"},{"location":"changelog/#v015-2025-06-02","title":"[v0.1.5] - 2025-06-02","text":"<ul> <li>Switch from <code>poetry</code> to <code>uv</code></li> <li>The python required version is now <code>&gt;=3.9</code></li> </ul>"},{"location":"changelog/#v014-2025-05-25","title":"[v0.1.4] - 2025-05-25","text":"<ul> <li>Remove inappropriate VS Code settings</li> </ul>"},{"location":"changelog/#v013-2025-05-16","title":"[v0.1.3] - 2025-05-16","text":"<ul> <li>Addind <code>test_serde_union_discrim</code></li> </ul>"},{"location":"changelog/#v012-2025-05-16","title":"[v0.1.2] - 2025-05-16","text":"<ul> <li>Added pipelex github repository in <code>README.md</code></li> </ul>"},{"location":"changelog/#v011-2025-05-12","title":"[v0.1.1] - 2025-05-12","text":"<ul> <li>Fix description, <code>project.urls</code> and some other fields of <code>pyproject.toml</code></li> <li>fix allowlist of CLA GHA</li> </ul>"},{"location":"changelog/#v010-2025-05-12","title":"[v0.1.0] - 2025-05-12","text":"<ul> <li>Initial release \ud83c\udf89</li> </ul>"},{"location":"contributing/","title":"Contributing to Kajson","text":"<p>Thank you for your interest in Kajson! While Kajson is a stable and feature-complete library, we do accept contributions if you find bugs or have improvements to suggest.</p> <p>Kajson is a powerful drop-in replacement for Python's standard <code>json</code> module that automatically handles complex object serialization, including Pydantic v2 models, datetime objects, and custom types. The library is maintained by the same team that develops Pipelex.</p> <p>Everyone interacting in codebases, issue trackers, mailing lists, or any other Kajson activities is expected to follow the Code of Conduct. Please review it before getting started.</p> <p>If you have questions or want to discuss potential contributions, feel free to join our community on Discord in the #code-contributions channel.</p> <p>Most of the issues that are open for contributions are tagged with <code>good first issue</code> or <code>help-welcome</code>. If you see an issue that isn't tagged that you're interested in, post a comment with your approach, and we'll be happy to assign it to you. If you submit a fix that isn't linked to an issue you're assigned, there's a chance it won't be accepted. Don't hesitate to open an issue to discuss your ideas before getting to work.</p> <p>Since Kajson is a mature library, most contributions will likely be:</p> <ul> <li>Bug fixes: Edge cases in serialization/deserialization</li> <li>Type support: Adding support for additional third-party library types</li> <li>Documentation: Improving examples and clarifications</li> <li>Performance: Optimizations that don't break existing functionality</li> </ul>"},{"location":"contributing/#contribution-process","title":"Contribution process","text":"<ul> <li>Fork the Kajson repository</li> <li>Clone the repository locally</li> <li>Install dependencies: <code>make install</code> (creates .venv and installs dependencies)</li> <li>Run checks to make sure all is good: <code>make check</code> &amp; <code>make test</code></li> <li>Create a branch with the format <code>user_name/category/short_slug</code> where category is one of: <code>feature</code>, <code>fix</code>, <code>refactor</code>, <code>docs</code>, <code>cicd</code> or <code>chore</code></li> <li>Make and commit changes</li> <li>Push your local branch to your fork</li> <li>Open a PR that links to an existing Issue which does not include the <code>needs triage</code> label</li> <li>Write a PR title and description by filling the template</li> <li>CI tests will be triggered and maintainers will review the code</li> <li>Respond to feedback if required</li> <li>Merge the contribution</li> </ul>"},{"location":"contributing/#requirements","title":"Requirements","text":"<ul> <li>Python \u2265 3.9</li> <li>uv \u2265 0.7.2</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ul> <li>Fork &amp; clone the repository</li> <li>Run <code>make install</code> to set up virtualenv and dependencies</li> <li>Use uv for dependency management:</li> <li>Runtime deps: <code>uv add &lt;package&gt;</code></li> <li>Dev deps: <code>uv add --dev &lt;package&gt;</code></li> <li>Keep dependencies alphabetically ordered in pyproject.toml</li> </ul>"},{"location":"contributing/#available-make-commands","title":"Available Make Commands","text":"<pre><code># Setup\nmake install              # Create local virtualenv &amp; install all dependencies\nmake update              # Upgrade dependencies via uv\nmake build               # Build the wheels\n\n# Code Quality\nmake check               # Run format, lint, mypy, and pyright\nmake format              # Format with ruff\nmake lint                # Lint with ruff\nmake pyright            # Check types with pyright\nmake mypy               # Check types with mypy\nmake fix-unused-imports # Fix unused imports\n\n# Testing\nmake test               # Run unit tests\nmake tp                 # Run tests with prints (useful for debugging)\nmake cov                # Run tests with coverage\nmake cm                 # Run tests with coverage and missing lines\n\n# Documentation\nmake dosc               # Serve documentation locally with mkdocs\nmake docs-check         # Check documentation build\nmake docs-deploy        # Deploy documentation to GitHub Pages\n\n# Cleanup\nmake cleanall           # Remove all derived files and virtual env\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the Kajson repository</li> <li>Clone the repository locally</li> <li>Install dependencies: <code>make install</code></li> <li>Run checks to ensure everything works: <code>make check</code> &amp; <code>make test</code></li> <li>Create a branch for your feature/bug-fix with the format <code>user_name/feature/some_feature</code> or <code>user_name/fix/some_bugfix</code></li> <li>Make and commit changes</li> <li>Write tests for your changes (Kajson aims for high test coverage)</li> <li>When ready, run quality checks:</li> <li>Run <code>make fix-unused-imports</code> to remove unused imports</li> <li>Run <code>make check</code> for formatting, linting, and type-checking</li> <li>Run <code>make test</code> to ensure all tests pass</li> <li>Push your local branch to your fork</li> <li>Open a PR that links to an existing issue</li> <li>Fill out the PR template with a clear description</li> <li>Mark as Draft until CI passes</li> <li>Maintainers will review the code</li> <li>Respond to feedback if required</li> <li>Once approved, your contribution will be merged</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>We use <code>ruff</code> for formatting and linting</li> <li>Type hints are required for all new code</li> <li>Follow existing patterns in the codebase</li> <li>Document complex logic with comments</li> <li>Add docstrings to all public functions and classes</li> </ul>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":"<ul> <li>Write tests for all new functionality</li> <li>Tests should be in the <code>tests/</code> directory</li> <li>Use pytest for all tests</li> <li>Aim for high test coverage</li> <li>Test edge cases and error conditions</li> <li>Integration tests for encoder/decoder combinations are especially valuable</li> </ul>"},{"location":"contributing/#adding-new-type-support","title":"Adding New Type Support","text":"<p>When adding support for new types:</p> <ol> <li>Create encoder and decoder functions</li> <li>Register them in the appropriate registry</li> <li>Add comprehensive tests including:</li> <li>Basic serialization/deserialization</li> <li>Nested structures</li> <li>Edge cases (None, empty, special values)</li> <li>Error handling</li> <li>Update documentation with usage examples</li> </ol>"},{"location":"contributing/#license","title":"License","text":"<ul> <li>CLA \u2013 The first time you open a PR, the CLA-assistant bot will guide you through signing the Contributor License Agreement. The process uses the CLA assistant lite.</li> <li>Code of Conduct \u2013 Be kind. All interactions fall under <code>CODE_OF_CONDUCT.md</code>.</li> <li>License \u2013 Kajson is licensed under the Apache 2.0 License.</li> </ul>"},{"location":"license/","title":"License","text":"<pre><code>                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n</code></pre>"},{"location":"pages/credits/","title":"Credits","text":""},{"location":"pages/credits/#core-team","title":"Core Team","text":"<p>Kajson is developed and maintained by the team at Pipelex which is also behind the open-source language for repeatable AI workflows: Pipelex.</p>"},{"location":"pages/credits/#original-work","title":"Original Work","text":"<p>This project is heavily based on the excellent work from unijson by Bastien Pietropaoli. We are grateful for the foundation that unijson provided, which allowed us to build Kajson with enhanced features and Pydantic v2 support.</p>"},{"location":"pages/credits/#contributors","title":"Contributors","text":"<p>We thank all contributors who have helped improve Kajson through bug reports, feature suggestions, and code contributions. Special thanks to:</p> <ul> <li>The Pydantic team for creating an amazing data validation library</li> <li>The Python community for the great ecosystem</li> </ul>"},{"location":"pages/credits/#open-source-libraries","title":"Open Source Libraries","text":"<p>Kajson stands on the shoulders of giants. We'd like to acknowledge the following projects:</p> <ul> <li>Python - The programming language that makes it all possible</li> <li>Pydantic - Data validation using Python type annotations</li> <li>pytest - Testing framework</li> <li>MkDocs - Documentation framework</li> <li>Material for MkDocs - Beautiful documentation theme</li> </ul>"},{"location":"pages/credits/#license","title":"License","text":"<p>Kajson is distributed under the Apache License 2.0, the same license as the original unijson project.</p>"},{"location":"pages/credits/#support","title":"Support","text":"<p>For questions, bug reports, or feature requests:</p> <ul> <li>Open an issue on GitHub</li> <li>Join our community on Discord</li> <li>Check out Pipelex for AI workflow automation using Kajson</li> </ul>"},{"location":"pages/installation/","title":"Installation","text":"<p>Kajson requires Python 3.9 or higher and can be installed using your favorite package manager.</p>"},{"location":"pages/installation/#requirements","title":"Requirements","text":"<ul> <li>Python \u2265 3.9</li> <li>Pydantic v2 (installed automatically)</li> </ul>"},{"location":"pages/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"pages/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install kajson\n</code></pre>"},{"location":"pages/installation/#using-poetry","title":"Using poetry","text":"<pre><code>poetry add kajson\n</code></pre>"},{"location":"pages/installation/#using-uv-recommended","title":"Using uv (recommended)","text":"<pre><code>uv pip install kajson\n</code></pre>"},{"location":"pages/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to Kajson or install from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/Pipelex/kajson.git\ncd kajson\n\n# Install with development dependencies\nmake install\n</code></pre>"},{"location":"pages/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, you can verify that Kajson is properly installed:</p> <pre><code>import kajson\n\n# Check version\nprint(kajson.__version__)\n\n# Test basic functionality\ndata = {\"message\": \"Hello, Kajson!\"}\njson_str = kajson.dumps(data)\nprint(json_str)\n</code></pre>"},{"location":"pages/installation/#next-steps","title":"Next Steps","text":"<p>Once installed, check out the Quick Start Guide to begin using Kajson in your projects. </p>"},{"location":"pages/quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with Kajson in minutes! This guide covers the most common use cases.</p>"},{"location":"pages/quick-start/#basic-usage","title":"Basic Usage","text":"<p>Kajson is designed as a drop-in replacement for Python's standard <code>json</code> module:</p> <pre><code>import kajson\n\n# Works just like standard json\ndata = {\"name\": \"Alice\", \"age\": 30}\njson_str = kajson.dumps(data)\nrestored = kajson.loads(json_str)\n</code></pre>"},{"location":"pages/quick-start/#working-with-pydantic-models","title":"Working with Pydantic Models","text":"<p>The real power of Kajson comes when working with complex objects:</p> <pre><code>from datetime import datetime\nfrom pydantic import BaseModel\nimport kajson\n\nclass User(BaseModel):\n    name: str\n    email: str\n    created_at: datetime\n    is_active: bool = True\n\n# Create a user\nuser = User(\n    name=\"Alice\",\n    email=\"alice@example.com\",\n    created_at=datetime.now()\n)\n\n# Serialize to JSON\njson_str = kajson.dumps(user, indent=2)\nprint(json_str)\n\n# Deserialize back to User object\nrestored_user = kajson.loads(json_str)\nassert isinstance(restored_user, User)\nassert user == restored_user\n</code></pre>"},{"location":"pages/quick-start/#datetime-support","title":"DateTime Support","text":"<p>Kajson automatically handles datetime objects:</p> <pre><code>from datetime import datetime, date, time, timedelta\nimport kajson\n\ndata = {\n    \"meeting_date\": date(2025, 1, 15),\n    \"meeting_time\": time(14, 30),\n    \"meeting_datetime\": datetime(2025, 1, 15, 14, 30),\n    \"duration\": timedelta(hours=1, minutes=30)\n}\n\n# Serialize and deserialize\njson_str = kajson.dumps(data)\nrestored = kajson.loads(json_str)\n\n# All types are preserved\nassert isinstance(restored[\"meeting_date\"], date)\nassert isinstance(restored[\"duration\"], timedelta)\n</code></pre>"},{"location":"pages/quick-start/#nested-objects","title":"Nested Objects","text":"<p>Kajson handles complex nested structures seamlessly:</p> <pre><code>from typing import List\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nclass Comment(BaseModel):\n    text: str\n    author: str\n    created_at: datetime\n\nclass Post(BaseModel):\n    title: str\n    content: str\n    comments: List[Comment]\n    tags: List[str]\n\n# Create nested structure\npost = Post(\n    title=\"Getting Started with Kajson\",\n    content=\"Kajson makes JSON serialization easy...\",\n    comments=[\n        Comment(text=\"Great post!\", author=\"Bob\", created_at=datetime.now()),\n        Comment(text=\"Very helpful\", author=\"Carol\", created_at=datetime.now())\n    ],\n    tags=[\"python\", \"json\", \"tutorial\"]\n)\n\n# Works perfectly\njson_str = kajson.dumps(post)\nrestored_post = kajson.loads(json_str)\n</code></pre>"},{"location":"pages/quick-start/#file-operations","title":"File Operations","text":"<p>Just like standard json, Kajson supports file operations:</p> <pre><code>import kajson\n\n# Save to file\nwith open(\"data.json\", \"w\") as f:\n    kajson.dump(user, f, indent=2)\n\n# Load from file\nwith open(\"data.json\", \"r\") as f:\n    loaded_user = kajson.load(f)\n</code></pre>"},{"location":"pages/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Basic Usage patterns</li> <li>Explore Pydantic Integration in depth</li> <li>Discover how to work with Custom Types</li> <li>Check out practical Examples </li> </ul>"},{"location":"pages/api/decoder/","title":"Decoder API Reference","text":"<p>The decoder module provides classes and utilities for deserializing JSON back to Python objects with type reconstruction.</p>"},{"location":"pages/api/decoder/#universaljsondecoder","title":"UniversalJSONDecoder","text":"<p>The main decoder class that extends <code>json.JSONDecoder</code> to reconstruct original Python types.</p>"},{"location":"pages/api/decoder/#class-definition","title":"Class Definition","text":"<pre><code>class UniversalJSONDecoder(json.JSONDecoder):\n    \"\"\"Enhanced JSON decoder with support for type reconstruction\"\"\"\n</code></pre>"},{"location":"pages/api/decoder/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    *,\n    object_hook: Callable[[dict[str, Any]], Any] | None = None,\n    parse_float: Callable[[str], Any] | None = None,\n    parse_int: Callable[[str], Any] | None = None,\n    parse_constant: Callable[[str], Any] | None = None,\n    strict: bool = True,\n    object_pairs_hook: Callable[[list[tuple[str, Any]]], Any] | None = None\n) -&gt; None\n</code></pre> <p>Parameters: Same as <code>json.JSONDecoder</code>, with enhanced object_hook functionality</p>"},{"location":"pages/api/decoder/#methods","title":"Methods","text":""},{"location":"pages/api/decoder/#decode","title":"decode","text":"<pre><code>def decode(self, s: str) -&gt; Any\n</code></pre> <p>Decode a JSON document to a Python object with type reconstruction.</p> <p>Parameters: - <code>s</code>: JSON string to decode</p> <p>Returns: Reconstructed Python object</p> <p>Raises: - <code>JSONDecodeError</code>: For invalid JSON syntax - <code>KajsonDecoderError</code>: For type reconstruction failures</p>"},{"location":"pages/api/decoder/#class-methods","title":"Class Methods","text":""},{"location":"pages/api/decoder/#register","title":"register","text":"<pre><code>@classmethod\ndef register(\n    cls,\n    type_class: Type,\n    decoder: Callable[[dict], Any]\n) -&gt; None\n</code></pre> <p>Register a custom decoder function for a specific type.</p> <p>Parameters: - <code>type_class</code>: The Python type to register - <code>decoder</code>: Function that reconstructs instances from a dict</p> <p>Example:</p> <pre><code>from decimal import Decimal\n\ndef decode_decimal(data: dict) -&gt; Decimal:\n    if \"__decimal__\" not in data:\n        raise ValueError(\"Invalid decimal data\")\n    return Decimal(data[\"__decimal__\"])\n\nkajson.UniversalJSONDecoder.register(Decimal, decode_decimal)\n</code></pre>"},{"location":"pages/api/decoder/#unregister","title":"unregister","text":"<pre><code>@classmethod\ndef unregister(cls, type_class: Type) -&gt; None\n</code></pre> <p>Remove a previously registered decoder for a type.</p> <p>Parameters: - <code>type_class</code>: The type to unregister</p>"},{"location":"pages/api/decoder/#get_registered_types","title":"get_registered_types","text":"<pre><code>@classmethod\ndef get_registered_types(cls) -&gt; List[Type]\n</code></pre> <p>Get a list of all registered types.</p> <p>Returns: List of types with custom decoders</p>"},{"location":"pages/api/decoder/#built-in-decoders","title":"Built-in Decoders","text":"<p>Kajson includes built-in decoders for common types:</p>"},{"location":"pages/api/decoder/#datetime-decoder","title":"DateTime Decoder","text":"<pre><code>def json_decode_datetime(obj_dict: Dict[str, Any]) -&gt; datetime.datetime:\n    \"\"\"Decoder for datetimes (from module datetime).\"\"\"\n    if datetime_str := obj_dict.get(\"datetime\"):\n        dt = datetime.datetime.strptime(datetime_str, \"%Y-%m-%d %H:%M:%S.%f\")\n    else:\n        raise KajsonDecoderError(\"Could not decode datetime from json: datetime field is required\")\n\n    if tzinfo_str := obj_dict.get(\"tzinfo\"):\n        dt = dt.replace(tzinfo=ZoneInfo(tzinfo_str))\n    return dt\n</code></pre>"},{"location":"pages/api/decoder/#date-decoder","title":"Date Decoder","text":"<pre><code>def json_decode_date(obj_dict: Dict[str, str]) -&gt; datetime.date:\n    \"\"\"Decoder for dates (from module datetime).\"\"\"\n    # Split date string into parts and convert to integers\n    year, month, day = map(int, obj_dict[\"date\"].split(\"-\"))\n    return datetime.date(year, month, day)\n</code></pre>"},{"location":"pages/api/decoder/#time-decoder","title":"Time Decoder","text":"<pre><code>def json_decode_time(d: Dict[str, Any]) -&gt; datetime.time:\n    \"\"\"Decoder for times (from module datetime).\"\"\"\n    # Split time string into parts\n    time_parts = d[\"time\"].split(\":\")\n    hours = int(time_parts[0])\n    minutes = int(time_parts[1])\n    # Handle seconds and milliseconds\n    seconds_parts = time_parts[2].split(\".\")\n    seconds = int(seconds_parts[0])\n    milliseconds = int(seconds_parts[1])\n\n    return datetime.time(hours, minutes, seconds, milliseconds, tzinfo=d[\"tzinfo\"])\n</code></pre>"},{"location":"pages/api/decoder/#timedelta-decoder","title":"Timedelta Decoder","text":"<pre><code># Timedelta objects are automatically reconstructed from the \"seconds\" field\n# No explicit decoder needed - the constructor handles it directly\n</code></pre>"},{"location":"pages/api/decoder/#custom-decoder-implementation","title":"Custom Decoder Implementation","text":""},{"location":"pages/api/decoder/#basic-custom-decoder","title":"Basic Custom Decoder","text":"<pre><code>import kajson\nfrom typing import Dict, Any\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\ndef decode_point(data: Dict[str, Any]) -&gt; Point:\n    if \"__point__\" not in data:\n        raise ValueError(\"Not a Point object\")\n    return Point(data[\"x\"], data[\"y\"])\n\n# Register the decoder\nkajson.UniversalJSONDecoder.register(Point, decode_point)\n\n# Now Point objects can be deserialized\njson_str = '{\"__point__\": true, \"x\": 3.14, \"y\": 2.71}'\np = kajson.loads(json_str)\nassert isinstance(p, Point)\n</code></pre>"},{"location":"pages/api/decoder/#decoder-with-validation","title":"Decoder with Validation","text":"<pre><code>def decode_positive_int(data: Dict[str, Any]) -&gt; PositiveInt:\n    if \"__positive_int__\" not in data:\n        raise ValueError(\"Not a PositiveInt object\")\n\n    value = data[\"__positive_int__\"]\n    if not isinstance(value, int) or value &lt;= 0:\n        raise ValueError(f\"Invalid positive integer: {value}\")\n\n    return PositiveInt(value)\n\nclass PositiveInt:\n    def __init__(self, value: int):\n        if value &lt;= 0:\n            raise ValueError(\"Must be positive\")\n        self.value = value\n\nkajson.UniversalJSONDecoder.register(PositiveInt, decode_positive_int)\n</code></pre>"},{"location":"pages/api/decoder/#decoder-with-error-recovery","title":"Decoder with Error Recovery","text":"<pre><code>def decode_with_fallback(data: Dict[str, Any]) -&gt; Any:\n    \"\"\"Decoder that provides fallback for missing data\"\"\"\n    try:\n        if \"__custom__\" in data:\n            # Try to reconstruct custom object\n            return CustomClass(**data.get(\"fields\", {}))\n    except Exception as e:\n        # Log error and return dict as fallback\n        print(f\"Failed to decode custom object: {e}\")\n        return data\n</code></pre>"},{"location":"pages/api/decoder/#advanced-decoding-patterns","title":"Advanced Decoding Patterns","text":""},{"location":"pages/api/decoder/#recursive-type-decoding","title":"Recursive Type Decoding","text":"<pre><code>from typing import List, Optional, Dict, Any\n\nclass TreeNode:\n    def __init__(self, value: Any, children: Optional[List[\"TreeNode\"]] = None):\n        self.value = value\n        self.children = children or []\n\ndef decode_tree_node(data: Dict[str, Any]) -&gt; TreeNode:\n    if \"__tree_node__\" not in data:\n        raise ValueError(\"Not a TreeNode\")\n\n    # Children will be automatically decoded recursively\n    return TreeNode(\n        value=data[\"value\"],\n        children=data.get(\"children\", [])\n    )\n\nkajson.UniversalJSONDecoder.register(TreeNode, decode_tree_node)\n</code></pre>"},{"location":"pages/api/decoder/#type-safe-decoding","title":"Type-Safe Decoding","text":"<pre><code>from typing import TypeVar, Type\n\nT = TypeVar('T')\n\ndef safe_decode(\n    json_str: str,\n    expected_type: Type[T]\n) -&gt; T:\n    \"\"\"Decode with type checking\"\"\"\n    result = kajson.loads(json_str)\n\n    if not isinstance(result, expected_type):\n        raise TypeError(\n            f\"Expected {expected_type.__name__}, \"\n            f\"got {type(result).__name__}\"\n        )\n\n    return result\n\n# Usage\nuser_json = '{\"name\": \"Alice\", \"__class__\": \"User\", \"__module__\": \"__main__\"}'\nuser = safe_decode(user_json, User)  # Type-checked\n</code></pre>"},{"location":"pages/api/decoder/#polymorphic-decoding","title":"Polymorphic Decoding","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self) -&gt; float:\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius: float):\n        self.radius = radius\n\n    def area(self) -&gt; float:\n        return 3.14159 * self.radius ** 2\n\nclass Rectangle(Shape):\n    def __init__(self, width: float, height: float):\n        self.width = width\n        self.height = height\n\n    def area(self) -&gt; float:\n        return self.width * self.height\n\ndef decode_shape(data: Dict[str, Any]) -&gt; Shape:\n    \"\"\"Decode different shape types\"\"\"\n    if \"__circle__\" in data:\n        return Circle(data[\"radius\"])\n    elif \"__rectangle__\" in data:\n        return Rectangle(data[\"width\"], data[\"height\"])\n    else:\n        raise ValueError(\"Unknown shape type\")\n\n# Register for base class\nkajson.UniversalJSONDecoder.register(Shape, decode_shape)\n</code></pre>"},{"location":"pages/api/decoder/#integration-with-pydantic","title":"Integration with Pydantic","text":""},{"location":"pages/api/decoder/#custom-pydantic-decoding","title":"Custom Pydantic Decoding","text":"<pre><code>from pydantic import BaseModel, ValidationError\n\nclass StrictUser(BaseModel):\n    name: str\n    age: int\n\n    @classmethod\n    def __json_decode__(cls, data: dict) -&gt; \"StrictUser\":\n        \"\"\"Custom decoding with extra validation\"\"\"\n        # Pre-process data\n        if \"age\" in data and data[\"age\"] &lt; 0:\n            data[\"age\"] = 0  # Fix negative ages\n\n        try:\n            return cls(**data)\n        except ValidationError as e:\n            # Custom error handling\n            raise KajsonDecoderError(f\"Invalid user data: {e}\")\n</code></pre>"},{"location":"pages/api/decoder/#error-handling-in-decoders","title":"Error Handling in Decoders","text":""},{"location":"pages/api/decoder/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>def robust_decode(data: Dict[str, Any]) -&gt; Any:\n    \"\"\"Decoder with comprehensive error handling\"\"\"\n    try:\n        # Check for required fields\n        if \"__type__\" not in data:\n            raise ValueError(\"Missing type information\")\n\n        type_name = data[\"__type__\"]\n\n        # Validate type\n        if type_name not in ALLOWED_TYPES:\n            raise ValueError(f\"Unknown type: {type_name}\")\n\n        # Reconstruct object\n        obj_class = ALLOWED_TYPES[type_name]\n        return obj_class(**data.get(\"fields\", {}))\n\n    except KeyError as e:\n        raise KajsonDecoderError(f\"Missing required field: {e}\")\n    except TypeError as e:\n        raise KajsonDecoderError(f\"Type error during reconstruction: {e}\")\n    except Exception as e:\n        # Log unexpected errors\n        logger.error(f\"Unexpected decoding error: {e}\")\n        raise KajsonDecoderError(f\"Failed to decode object: {e}\")\n</code></pre>"},{"location":"pages/api/decoder/#decoder-with-logging","title":"Decoder with Logging","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\ndef logged_decode(data: Dict[str, Any]) -&gt; Any:\n    \"\"\"Decoder that logs all operations\"\"\"\n    logger.debug(f\"Decoding data: {data}\")\n\n    try:\n        result = perform_decode(data)\n        logger.debug(f\"Successfully decoded: {type(result).__name__}\")\n        return result\n    except Exception as e:\n        logger.error(f\"Decoding failed: {e}\", exc_info=True)\n        raise\n</code></pre>"},{"location":"pages/api/decoder/#performance-optimization","title":"Performance Optimization","text":""},{"location":"pages/api/decoder/#cached-decoders","title":"Cached Decoders","text":"<pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=256)\ndef get_decoder_for_type(type_name: str) -&gt; Optional[Callable]:\n    \"\"\"Cache decoder lookups for performance\"\"\"\n    for type_class, decoder in kajson.UniversalJSONDecoder._decoders.items():\n        if type_class.__name__ == type_name:\n            return decoder\n    return None\n</code></pre>"},{"location":"pages/api/decoder/#batch-decoding","title":"Batch Decoding","text":"<pre><code>def decode_batch(json_strings: List[str]) -&gt; List[Any]:\n    \"\"\"Efficiently decode multiple JSON strings\"\"\"\n    results = []\n    errors = []\n\n    for i, json_str in enumerate(json_strings):\n        try:\n            results.append(kajson.loads(json_str))\n        except Exception as e:\n            errors.append((i, str(e)))\n\n    if errors:\n        logger.warning(f\"Failed to decode {len(errors)} items\")\n\n    return results\n</code></pre>"},{"location":"pages/api/decoder/#see-also","title":"See Also","text":"<ul> <li>Encoder API - Corresponding encoder documentation</li> <li>kajson Module API - Main module functions</li> <li>Error Handling Guide - Handling decoder errors</li> </ul>"},{"location":"pages/api/encoder/","title":"Encoder API Reference","text":"<p>The encoder module provides classes and utilities for serializing Python objects to JSON with extended type support.</p>"},{"location":"pages/api/encoder/#universaljsonencoder","title":"UniversalJSONEncoder","text":"<p>The main encoder class that extends <code>json.JSONEncoder</code> to handle additional Python types.</p>"},{"location":"pages/api/encoder/#class-definition","title":"Class Definition","text":"<pre><code>class UniversalJSONEncoder(json.JSONEncoder):\n    \"\"\"Enhanced JSON encoder with support for custom types\"\"\"\n</code></pre>"},{"location":"pages/api/encoder/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    *,\n    skipkeys: bool = False,\n    ensure_ascii: bool = False,\n    check_circular: bool = True,\n    allow_nan: bool = True,\n    sort_keys: bool = False,\n    indent: int | str | None = None,\n    separators: tuple[str, str] | None = None,\n    default: Callable[[Any], Any] | None = None\n) -&gt; None\n</code></pre> <p>Parameters: Same as <code>json.JSONEncoder</code></p>"},{"location":"pages/api/encoder/#methods","title":"Methods","text":""},{"location":"pages/api/encoder/#default","title":"default","text":"<pre><code>def default(self, obj: Any) -&gt; Any\n</code></pre> <p>Override this method to provide custom serialization for objects that the standard encoder cannot handle.</p> <p>Parameters: - <code>obj</code>: Object to encode</p> <p>Returns: JSON-serializable representation of the object</p> <p>Example:</p> <pre><code>class MyEncoder(kajson.UniversalJSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, MyCustomClass):\n            return {\"custom\": obj.to_dict()}\n        return super().default(obj)\n</code></pre>"},{"location":"pages/api/encoder/#class-methods","title":"Class Methods","text":""},{"location":"pages/api/encoder/#register","title":"register","text":"<pre><code>@classmethod\ndef register(\n    cls,\n    type_class: Type,\n    encoder: Callable[[Any], dict]\n) -&gt; None\n</code></pre> <p>Register a custom encoder function for a specific type.</p> <p>Parameters: - <code>type_class</code>: The Python type to register - <code>encoder</code>: Function that converts instances of <code>type_class</code> to a dict</p> <p>Example:</p> <pre><code>from decimal import Decimal\n\ndef encode_decimal(value: Decimal) -&gt; dict:\n    return {\n        \"__decimal__\": str(value),\n        \"precision\": value.as_tuple().exponent\n    }\n\nkajson.UniversalJSONEncoder.register(Decimal, encode_decimal)\n</code></pre>"},{"location":"pages/api/encoder/#unregister","title":"unregister","text":"<pre><code>@classmethod\ndef unregister(cls, type_class: Type) -&gt; None\n</code></pre> <p>Remove a previously registered encoder for a type.</p> <p>Parameters: - <code>type_class</code>: The type to unregister</p>"},{"location":"pages/api/encoder/#get_registered_types","title":"get_registered_types","text":"<pre><code>@classmethod\ndef get_registered_types(cls) -&gt; List[Type]\n</code></pre> <p>Get a list of all registered types.</p> <p>Returns: List of types with custom encoders</p>"},{"location":"pages/api/encoder/#built-in-encoders","title":"Built-in Encoders","text":"<p>Kajson includes built-in encoders for common types:</p>"},{"location":"pages/api/encoder/#datetime-encoder","title":"DateTime Encoder","text":"<pre><code>def json_encode_datetime(datetime_value: datetime.datetime) -&gt; Dict[str, Any]:\n    \"\"\"Encoder for datetimes (from module datetime).\"\"\"\n    tzinfo = str(datetime_value.tzinfo) if datetime_value.tzinfo else None\n    # Ensure year is always formatted as 4 digits for cross-platform compatibility\n    datetime_str = (\n        f\"{datetime_value.year:04d}-{datetime_value.month:02d}-{datetime_value.day:02d} \"\n        f\"{datetime_value.hour:02d}:{datetime_value.minute:02d}:{datetime_value.second:02d}.{datetime_value.microsecond:06d}\"\n    )\n    return {\"datetime\": datetime_str, \"tzinfo\": tzinfo}\n</code></pre>"},{"location":"pages/api/encoder/#date-encoder","title":"Date Encoder","text":"<pre><code>def json_encode_date(d: datetime.date) -&gt; Dict[str, str]:\n    \"\"\"Encoder for dates (from module datetime).\"\"\"\n    return {\"date\": str(d)}\n</code></pre>"},{"location":"pages/api/encoder/#time-encoder","title":"Time Encoder","text":"<pre><code>def json_encode_time(t: datetime.time) -&gt; Dict[str, Any]:\n    \"\"\"Encoder for times (from module datetime).\"\"\"\n    return {\"time\": t.strftime(\"%H:%M:%S.%f\"), \"tzinfo\": t.tzinfo}\n</code></pre>"},{"location":"pages/api/encoder/#timedelta-encoder","title":"Timedelta Encoder","text":"<pre><code>def json_encode_timedelta(t: datetime.timedelta) -&gt; Dict[str, float]:\n    \"\"\"Encoder for timedeltas (from module datetime).\"\"\"\n    return {\"seconds\": t.total_seconds()}\n</code></pre>"},{"location":"pages/api/encoder/#timezone-encoder","title":"Timezone Encoder","text":"<pre><code>def json_encode_timezone(t: ZoneInfo) -&gt; Dict[str, Any]:\n    \"\"\"Encoder for timezones (using zoneinfo from Python 3.9+).\"\"\"\n    return {\"zone\": t.key}\n</code></pre>"},{"location":"pages/api/encoder/#automatic-metadata-handling","title":"Automatic Metadata Handling","text":"<p>Important: You'll notice that the built-in encoders above don't include <code>__class__</code> and <code>__module__</code> fields in their returned dictionaries. This is because <code>UniversalJSONEncoder</code> automatically adds these metadata fields to enable object reconstruction during decoding.</p>"},{"location":"pages/api/encoder/#how-it-works","title":"How It Works","text":"<p>When you register an encoder function, the <code>UniversalJSONEncoder</code> will:</p> <ol> <li>Call your encoder function to get the data dictionary</li> <li>Automatically add <code>__class__</code> and <code>__module__</code> fields if they're not already present</li> <li>Use these fields during decoding to reconstruct the original object type</li> </ol>"},{"location":"pages/api/encoder/#example","title":"Example","text":"<pre><code># Your encoder function\ndef encode_point(point: Point) -&gt; Dict[str, Any]:\n    return {\"x\": point.x, \"y\": point.y}  # No __class__ or __module__ needed\n\n# What gets serialized automatically:\n# {\n#     \"x\": 3.14,\n#     \"y\": 2.71,\n#     \"__class__\": \"Point\",      # Added automatically\n#     \"__module__\": \"__main__\"   # Added automatically\n# }\n</code></pre>"},{"location":"pages/api/encoder/#when-to-include-metadata-explicitly","title":"When to Include Metadata Explicitly","text":"<p>You should only include <code>__class__</code> and <code>__module__</code> explicitly when you want to override the automatic detection, such as:</p> <ul> <li>Using one encoder for multiple related types</li> <li>Encoding with a different class name than the actual type</li> <li>Creating cross-compatible encodings between different class hierarchies</li> </ul> <pre><code>def encode_shape(shape: Union[Circle, Rectangle]) -&gt; Dict[str, Any]:\n    return {\n        \"area\": shape.area(),\n        \"__class__\": \"Shape\",  # Override: use base class name\n        \"__module__\": \"geometry\"\n    }\n</code></pre>"},{"location":"pages/api/encoder/#custom-encoder-implementation","title":"Custom Encoder Implementation","text":""},{"location":"pages/api/encoder/#basic-custom-encoder","title":"Basic Custom Encoder","text":"<pre><code>import kajson\nfrom typing import Any, Dict\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\ndef encode_point(point: Point) -&gt; Dict[str, Any]:\n    return {\n        \"__point__\": True,\n        \"x\": point.x,\n        \"y\": point.y\n    }\n\n# Register the encoder\nkajson.UniversalJSONEncoder.register(Point, encode_point)\n\n# Now Point objects can be serialized\np = Point(3.14, 2.71)\njson_str = kajson.dumps(p)\n</code></pre>"},{"location":"pages/api/encoder/#encoder-with-validation","title":"Encoder with Validation","text":"<pre><code>def encode_positive_int(value: int) -&gt; Dict[str, Any]:\n    if value &lt;= 0:\n        raise ValueError(f\"Expected positive integer, got {value}\")\n    return {\"__positive_int__\": value}\n\nclass PositiveInt:\n    def __init__(self, value: int):\n        if value &lt;= 0:\n            raise ValueError(\"Must be positive\")\n        self.value = value\n\nkajson.UniversalJSONEncoder.register(PositiveInt, \n    lambda pi: encode_positive_int(pi.value))\n</code></pre>"},{"location":"pages/api/encoder/#conditional-encoding","title":"Conditional Encoding","text":"<pre><code>import os\n\ndef encode_path(path: Path) -&gt; Dict[str, Any]:\n    \"\"\"Encode path with additional metadata\"\"\"\n    result = {\"__path__\": str(path)}\n\n    # Add metadata if path exists\n    if path.exists():\n        result.update({\n            \"exists\": True,\n            \"is_file\": path.is_file(),\n            \"is_dir\": path.is_dir(),\n            \"size\": path.stat().st_size if path.is_file() else None\n        })\n    else:\n        result[\"exists\"] = False\n\n    return result\n</code></pre>"},{"location":"pages/api/encoder/#advanced-encoding-patterns","title":"Advanced Encoding Patterns","text":""},{"location":"pages/api/encoder/#recursive-type-encoding","title":"Recursive Type Encoding","text":"<pre><code>from typing import List, Optional\n\nclass TreeNode:\n    def __init__(self, value: Any, children: Optional[List[\"TreeNode\"]] = None):\n        self.value = value\n        self.children = children or []\n\ndef encode_tree_node(node: TreeNode) -&gt; Dict[str, Any]:\n    return {\n        \"__tree_node__\": True,\n        \"value\": node.value,\n        \"children\": node.children  # Recursively encoded\n    }\n\nkajson.UniversalJSONEncoder.register(TreeNode, encode_tree_node)\n\n# Create tree\nroot = TreeNode(\"root\", [\n    TreeNode(\"child1\", [TreeNode(\"grandchild1\")]),\n    TreeNode(\"child2\")\n])\n\n# Serialize entire tree\njson_str = kajson.dumps(root)\n</code></pre>"},{"location":"pages/api/encoder/#encoder-with-type-hints","title":"Encoder with Type Hints","text":"<pre><code>from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Box(Generic[T]):\n    def __init__(self, value: T):\n        self.value = value\n        self.type_name = type(value).__name__\n\ndef encode_box(box: Box) -&gt; Dict[str, Any]:\n    return {\n        \"__box__\": True,\n        \"value\": box.value,\n        \"type_hint\": box.type_name\n    }\n\nkajson.UniversalJSONEncoder.register(Box, encode_box)\n</code></pre>"},{"location":"pages/api/encoder/#performance-considerations","title":"Performance Considerations","text":""},{"location":"pages/api/encoder/#caching-encoders","title":"Caching Encoders","text":"<pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef get_encoder_for_type(type_class: Type) -&gt; Optional[Callable]:\n    \"\"\"Cache encoder lookups for performance\"\"\"\n    return kajson.UniversalJSONEncoder._encoders.get(type_class)\n</code></pre>"},{"location":"pages/api/encoder/#bulk-registration","title":"Bulk Registration","text":"<pre><code># Register multiple types at once\nencoders = {\n    IPv4Address: lambda ip: {\"__ipv4__\": str(ip)},\n    IPv6Address: lambda ip: {\"__ipv6__\": str(ip)},\n    UUID: lambda u: {\"__uuid__\": str(u)},\n    Path: lambda p: {\"__path__\": str(p)}\n}\n\nfor type_class, encoder in encoders.items():\n    kajson.UniversalJSONEncoder.register(type_class, encoder)\n</code></pre>"},{"location":"pages/api/encoder/#error-handling-in-encoders","title":"Error Handling in Encoders","text":""},{"location":"pages/api/encoder/#safe-encoding-pattern","title":"Safe Encoding Pattern","text":"<pre><code>def safe_encode(value: Any) -&gt; Dict[str, Any]:\n    \"\"\"Encoder with comprehensive error handling\"\"\"\n    try:\n        # Validate input\n        if value is None:\n            return {\"__null__\": True}\n\n        # Perform encoding\n        result = {\n            \"__type__\": type(value).__name__,\n            \"data\": str(value)\n        }\n\n        # Validate output\n        if not isinstance(result, dict):\n            raise TypeError(\"Encoder must return a dict\")\n\n        return result\n\n    except Exception as e:\n        # Log error and re-raise\n        print(f\"Encoding error for {type(value)}: {e}\")\n        raise\n</code></pre>"},{"location":"pages/api/encoder/#integration-with-pydantic","title":"Integration with Pydantic","text":"<p>Kajson automatically handles Pydantic models, but you can customize the encoding:</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    internal_field: str = \"secret\"\n\n    def __json_encode__(self) -&gt; dict:\n        \"\"\"Custom encoding that excludes internal fields\"\"\"\n        data = self.model_dump()\n        data.pop('internal_field', None)\n        return data\n</code></pre>"},{"location":"pages/api/encoder/#see-also","title":"See Also","text":"<ul> <li>Decoder API - Corresponding decoder documentation</li> <li>kajson Module API - Main module functions</li> <li>Custom Types Guide - Tutorial on adding custom types</li> </ul>"},{"location":"pages/api/kajson/","title":"kajson Module API Reference","text":"<p>The main <code>kajson</code> module provides drop-in replacement functions for Python's standard <code>json</code> module with enhanced type support.</p>"},{"location":"pages/api/kajson/#core-functions","title":"Core Functions","text":""},{"location":"pages/api/kajson/#dumps","title":"dumps","text":"<pre><code>def dumps(\n    obj: Any,\n    *,\n    skipkeys: bool = False,\n    ensure_ascii: bool = False,\n    check_circular: bool = True,\n    allow_nan: bool = True,\n    cls: Type[JSONEncoder] | None = None,\n    indent: int | str | None = None,\n    separators: tuple[str, str] | None = None,\n    default: Callable[[Any], Any] | None = None,\n    sort_keys: bool = False,\n    **kw: Any\n) -&gt; str\n</code></pre> <p>Serialize <code>obj</code> to a JSON formatted string using the enhanced encoder.</p> <p>Parameters:</p> <ul> <li><code>obj</code>: The Python object to serialize</li> <li><code>skipkeys</code>: If True, skip keys that are not basic types (default: False)</li> <li><code>ensure_ascii</code>: If True, escape all non-ASCII characters (default: False)</li> <li><code>check_circular</code>: If False, skip circular reference check (default: True)</li> <li><code>allow_nan</code>: If True, allow NaN, Infinity, -Infinity (default: True)</li> <li><code>cls</code>: Custom encoder class (default: UniversalJSONEncoder)</li> <li><code>indent</code>: Number of spaces for indentation, or None for compact output</li> <li><code>separators</code>: Tuple of (item_separator, key_separator)</li> <li><code>default</code>: Function called for objects that can't be serialized</li> <li><code>sort_keys</code>: If True, sort dictionary keys (default: False)</li> <li><code>**kw</code>: Additional keyword arguments passed to the encoder</li> </ul> <p>Returns: JSON string representation of the object</p> <p>Example:</p> <pre><code>import kajson\nfrom datetime import datetime\n\ndata = {\n    \"name\": \"Alice\",\n    \"created_at\": datetime.now(),\n    \"active\": True\n}\n\njson_str = kajson.dumps(data, indent=2)\nprint(json_str)\n</code></pre>"},{"location":"pages/api/kajson/#loads","title":"loads","text":"<pre><code>def loads(\n    s: str | bytes | bytearray,\n    *,\n    cls: Type[JSONDecoder] | None = None,\n    object_hook: Callable[[dict[str, Any]], Any] | None = None,\n    parse_float: Callable[[str], Any] | None = None,\n    parse_int: Callable[[str], Any] | None = None,\n    parse_constant: Callable[[str], Any] | None = None,\n    object_pairs_hook: Callable[[list[tuple[str, Any]]], Any] | None = None,\n    **kw: Any\n) -&gt; Any\n</code></pre> <p>Deserialize a JSON string to a Python object with type reconstruction.</p> <p>Parameters:</p> <ul> <li><code>s</code>: JSON string, bytes, or bytearray to deserialize</li> <li><code>cls</code>: Custom decoder class (default: UniversalJSONDecoder)</li> <li><code>object_hook</code>: Function called with every JSON object decoded</li> <li><code>parse_float</code>: Function to parse float values</li> <li><code>parse_int</code>: Function to parse integer values</li> <li><code>parse_constant</code>: Function to parse constants (NaN, Infinity, -Infinity)</li> <li><code>object_pairs_hook</code>: Function called with ordered list of pairs</li> <li><code>**kw</code>: Additional keyword arguments passed to the decoder</li> </ul> <p>Returns: Deserialized Python object</p> <p>Raises: - <code>JSONDecodeError</code>: If the JSON syntax is invalid - <code>KajsonDecoderError</code>: If type reconstruction fails</p> <p>Example:</p> <pre><code>import kajson\n\njson_str = '{\"name\": \"Alice\", \"age\": 30}'\ndata = kajson.loads(json_str)\nprint(data)  # {'name': 'Alice', 'age': 30}\n</code></pre>"},{"location":"pages/api/kajson/#dump","title":"dump","text":"<pre><code>def dump(\n    obj: Any,\n    fp: IO[str],\n    *,\n    skipkeys: bool = False,\n    ensure_ascii: bool = False,\n    check_circular: bool = True,\n    allow_nan: bool = True,\n    cls: Type[JSONEncoder] | None = None,\n    indent: int | str | None = None,\n    separators: tuple[str, str] | None = None,\n    default: Callable[[Any], Any] | None = None,\n    sort_keys: bool = False,\n    **kw: Any\n) -&gt; None\n</code></pre> <p>Serialize <code>obj</code> to a JSON formatted stream.</p> <p>Parameters:</p> <ul> <li><code>obj</code>: The Python object to serialize</li> <li><code>fp</code>: File-like object supporting <code>.write()</code></li> <li>Other parameters: Same as <code>dumps()</code></li> </ul> <p>Example:</p> <pre><code>import kajson\nfrom datetime import date\n\ndata = {\n    \"event\": \"Conference\",\n    \"date\": date(2025, 3, 15),\n    \"attendees\": 150\n}\n\nwith open(\"event.json\", \"w\") as f:\n    kajson.dump(data, f, indent=2)\n</code></pre>"},{"location":"pages/api/kajson/#load","title":"load","text":"<pre><code>def load(\n    fp: IO[str] | IO[bytes],\n    *,\n    cls: Type[JSONDecoder] | None = None,\n    object_hook: Callable[[dict[str, Any]], Any] | None = None,\n    parse_float: Callable[[str], Any] | None = None,\n    parse_int: Callable[[str], Any] | None = None,\n    parse_constant: Callable[[str], Any] | None = None,\n    object_pairs_hook: Callable[[list[tuple[str, Any]]], Any] | None = None,\n    **kw: Any\n) -&gt; Any\n</code></pre> <p>Deserialize a JSON file to a Python object.</p> <p>Parameters:</p> <ul> <li><code>fp</code>: File-like object supporting <code>.read()</code></li> <li>Other parameters: Same as <code>loads()</code></li> </ul> <p>Returns: Deserialized Python object</p> <p>Example:</p> <pre><code>import kajson\n\nwith open(\"data.json\", \"r\") as f:\n    data = kajson.load(f)\n</code></pre>"},{"location":"pages/api/kajson/#special-classes","title":"Special Classes","text":""},{"location":"pages/api/kajson/#universaljsonencoder","title":"UniversalJSONEncoder","text":"<p>The default encoder class that handles extended types. Can be subclassed for custom behavior.</p> <p>Class Methods:</p> <pre><code>@classmethod\ndef register(cls, type_class: Type, encoder: Callable[[Any], dict]) -&gt; None\n</code></pre> <p>Register a custom encoder for a specific type.</p> <p>Example:</p> <pre><code>from decimal import Decimal\n\ndef encode_decimal(d: Decimal) -&gt; dict:\n    return {\"__decimal__\": str(d)}\n\nkajson.UniversalJSONEncoder.register(Decimal, encode_decimal)\n</code></pre>"},{"location":"pages/api/kajson/#universaljsondecoder","title":"UniversalJSONDecoder","text":"<p>The default decoder class that reconstructs original types. Can be subclassed for custom behavior.</p> <p>Class Methods:</p> <pre><code>@classmethod\ndef register(cls, type_class: Type, decoder: Callable[[dict], Any]) -&gt; None\n</code></pre> <p>Register a custom decoder for a specific type.</p> <p>Example:</p> <pre><code>from decimal import Decimal\n\ndef decode_decimal(data: dict) -&gt; Decimal:\n    return Decimal(data[\"__decimal__\"])\n\nkajson.UniversalJSONDecoder.register(Decimal, decode_decimal)\n</code></pre>"},{"location":"pages/api/kajson/#exceptions","title":"Exceptions","text":""},{"location":"pages/api/kajson/#jsondecodeerror","title":"JSONDecodeError","text":"<p>Standard JSON syntax error, inherited from <code>json.JSONDecodeError</code>.</p> <p>Attributes: - <code>msg</code>: Error message - <code>doc</code>: JSON document being parsed - <code>pos</code>: Position where error occurred</p>"},{"location":"pages/api/kajson/#kajsondecodererror","title":"KajsonDecoderError","text":"<p>Raised when type reconstruction fails during deserialization.</p> <p>Example:</p> <pre><code>try:\n    kajson.loads(invalid_json)\nexcept kajson.JSONDecodeError as e:\n    print(f\"Invalid JSON at position {e.pos}: {e.msg}\")\nexcept kajson.KajsonDecoderError as e:\n    print(f\"Type reconstruction failed: {e}\")\n</code></pre>"},{"location":"pages/api/kajson/#type-support","title":"Type Support","text":""},{"location":"pages/api/kajson/#built-in-type-support","title":"Built-in Type Support","text":"<p>Kajson automatically handles these types without configuration:</p> <ul> <li>All standard JSON types (dict, list, str, int, float, bool, None)</li> <li><code>datetime.datetime</code></li> <li><code>datetime.date</code></li> <li><code>datetime.time</code></li> <li><code>datetime.timedelta</code></li> <li><code>datetime.timezone</code></li> <li>Pydantic BaseModel (v2)</li> <li>Classes with <code>__json_encode__</code> and <code>__json_decode__</code> methods</li> </ul>"},{"location":"pages/api/kajson/#custom-type-hooks","title":"Custom Type Hooks","text":"<p>Classes can implement these methods for automatic serialization:</p> <pre><code>class MyClass:\n    def __json_encode__(self) -&gt; dict:\n        \"\"\"Return dict representation for JSON encoding\"\"\"\n        return {\"data\": self.data}\n\n    @classmethod\n    def __json_decode__(cls, data: dict) -&gt; \"MyClass\":\n        \"\"\"Reconstruct instance from dict\"\"\"\n        return cls(data[\"data\"])\n</code></pre>"},{"location":"pages/api/kajson/#complete-example","title":"Complete Example","text":"<pre><code>import kajson\nfrom datetime import datetime, timedelta\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass Task(BaseModel):\n    id: int\n    title: str\n    due_date: datetime\n    estimated_time: timedelta\n    tags: List[str]\n\n# Create tasks\ntasks = [\n    Task(\n        id=1,\n        title=\"Write documentation\",\n        due_date=datetime(2025, 2, 1, 17, 0),\n        estimated_time=timedelta(hours=3),\n        tags=[\"docs\", \"priority\"]\n    ),\n    Task(\n        id=2,\n        title=\"Review PRs\",\n        due_date=datetime(2025, 2, 2, 10, 0),\n        estimated_time=timedelta(hours=1, minutes=30),\n        tags=[\"review\", \"team\"]\n    )\n]\n\n# Serialize to JSON\njson_str = kajson.dumps(tasks, indent=2)\nprint(\"Serialized:\", json_str)\n\n# Save to file\nwith open(\"tasks.json\", \"w\") as f:\n    kajson.dump(tasks, f, indent=2)\n\n# Load from file\nwith open(\"tasks.json\", \"r\") as f:\n    loaded_tasks = kajson.load(f)\n\n# Verify types are preserved\nfor task in loaded_tasks:\n    assert isinstance(task, Task)\n    assert isinstance(task.due_date, datetime)\n    assert isinstance(task.estimated_time, timedelta)\n\nprint(f\"Successfully loaded {len(loaded_tasks)} tasks\")\n</code></pre>"},{"location":"pages/api/kajson/#see-also","title":"See Also","text":"<ul> <li>Encoder API - Detailed encoder documentation</li> <li>Decoder API - Detailed decoder documentation</li> <li>Custom Types Guide - How to add custom type support</li> </ul>"},{"location":"pages/api/manager/","title":"KajsonManager API Reference","text":"<p>The <code>KajsonManager</code> class provides a singleton interface for managing kajson operations, including class registry management and logger configuration.</p>"},{"location":"pages/api/manager/#kajsonmanager-class","title":"KajsonManager Class","text":""},{"location":"pages/api/manager/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    logger_channel_name: Optional[str] = None,\n    class_registry: Optional[ClassRegistryAbstract] = None,\n) -&gt; None\n</code></pre> <p>Initialize the KajsonManager singleton instance.</p> <p>Parameters:</p> <ul> <li><code>logger_channel_name</code>: Name of the logger channel (default: \"kajson\")</li> <li><code>class_registry</code>: Custom class registry implementation (default: ClassRegistry())</li> </ul> <p>Note</p> <p>KajsonManager is a singleton class. Multiple calls to the constructor will return the same instance.</p>"},{"location":"pages/api/manager/#class-methods","title":"Class Methods","text":""},{"location":"pages/api/manager/#get_instance","title":"get_instance","text":"<pre><code>@classmethod\ndef get_instance(cls) -&gt; KajsonManager\n</code></pre> <p>Get the singleton instance of KajsonManager. Creates one if it doesn't exist.</p> <p>Returns: The singleton KajsonManager instance</p> <p>Example:</p> <pre><code>from kajson.kajson_manager import KajsonManager\n\nmanager = KajsonManager.get_instance()\n</code></pre>"},{"location":"pages/api/manager/#teardown","title":"teardown","text":"<pre><code>@classmethod\ndef teardown(cls) -&gt; None\n</code></pre> <p>Destroy the singleton instance. Useful for testing or cleanup scenarios.</p> <p>Example:</p> <pre><code>from kajson.kajson_manager import KajsonManager\n\n# Clean up the singleton instance\nKajsonManager.teardown()\n</code></pre>"},{"location":"pages/api/manager/#get_class_registry","title":"get_class_registry","text":"<pre><code>@classmethod\ndef get_class_registry(cls) -&gt; ClassRegistryAbstract\n</code></pre> <p>Get the class registry from the singleton instance.</p> <p>Returns: The class registry instance used for managing custom type serialization</p> <p>Example:</p> <pre><code>from kajson.kajson_manager import KajsonManager\n\nregistry = KajsonManager.get_class_registry()\n</code></pre>"},{"location":"pages/api/manager/#usage-examples","title":"Usage Examples","text":""},{"location":"pages/api/manager/#basic-usage","title":"Basic Usage","text":"<pre><code>from kajson.kajson_manager import KajsonManager\n\n# Get the singleton instance\nmanager = KajsonManager.get_instance()\n\n# Access the class registry\nregistry = manager._class_registry\n# or use the class method\nregistry = KajsonManager.get_class_registry()\n</code></pre>"},{"location":"pages/api/manager/#custom-configuration","title":"Custom Configuration","text":"<pre><code>from kajson.kajson_manager import KajsonManager\nfrom kajson.class_registry import ClassRegistry\n\n# Initialize with custom logger channel\nmanager = KajsonManager(logger_channel_name=\"my_logger\")\n\n# Or with custom class registry\ncustom_registry = ClassRegistry()\nmanager = KajsonManager(class_registry=custom_registry)\n</code></pre>"},{"location":"pages/api/manager/#testing-and-cleanup","title":"Testing and Cleanup","text":"<pre><code>from kajson.kajson_manager import KajsonManager\n\n# In test setup - ensure clean state\nKajsonManager.teardown()\n\n# Use the manager in tests\nmanager = KajsonManager.get_instance()\n\n# In test teardown\nKajsonManager.teardown()\n</code></pre> <p>Tip</p> <p>The KajsonManager is primarily used internally by kajson. Most users won't need to interact with it directly unless they're implementing custom serialization logic or need to access the class registry programmatically. </p>"},{"location":"pages/examples/","title":"Examples","text":"<p>This section contains practical examples demonstrating how to use Kajson. All examples are available as executable files in the <code>examples/</code> directory.</p>"},{"location":"pages/examples/#basic-pydantic-model-serialization","title":"Basic Pydantic Model Serialization","text":"<p>Source: <code>ex_01_basic_pydantic_serialization.py</code></p> <p>Shows how to serialize and deserialize Pydantic models with datetime fields - no special handling required.</p> <pre><code>from datetime import datetime\nfrom pydantic import BaseModel\nfrom kajson import kajson, kajson_manager\n\nclass User(BaseModel):\n    name: str\n    email: str\n    created_at: datetime\n\ndef main():\n    # Create and serialize\n    user = User(\n        name=\"Alice\",\n        email=\"alice@example.com\",\n        created_at=datetime.now()\n    )\n\n    # Serialize to JSON\n    json_str = kajson.dumps(user, indent=2)\n\n    # Deserialize back\n    restored_user = kajson.loads(json_str)\n    assert user == restored_user  # \u2705 Perfect reconstruction!\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre>"},{"location":"pages/examples/#nested-models-with-mixed-types","title":"Nested Models with Mixed Types","text":"<p>Source: <code>ex_02_nested_models_mixed_types.py</code></p> <p>Demonstrates handling complex nested structures with multiple Pydantic models, lists, datetime and timedelta types.</p> <pre><code>from datetime import datetime, timedelta\nfrom typing import List\nfrom pydantic import BaseModel\nfrom kajson import kajson, kajson_manager\n\nclass Comment(BaseModel):\n    author: str\n    text: str\n    posted_at: datetime\n\nclass BlogPost(BaseModel):\n    title: str\n    content: str\n    published_at: datetime\n    read_time: timedelta\n    comments: List[Comment]\n\ndef main():\n    # Create complex nested structure\n    post = BlogPost(\n        title=\"Kajson Makes JSON Easy\",\n        content=\"No more 'not JSON serializable' errors!\",\n        published_at=datetime.now(),\n        read_time=timedelta(minutes=5),\n        comments=[\n            Comment(author=\"Bob\", text=\"Great post!\", posted_at=datetime.now()),\n            Comment(author=\"Carol\", text=\"Very helpful\", posted_at=datetime.now())\n        ]\n    )\n\n    # Works seamlessly!\n    json_str = kajson.dumps(post)\n    restored = kajson.loads(json_str)\n    assert post == restored\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre>"},{"location":"pages/examples/#custom-classes-with-json-hooks","title":"Custom Classes with JSON Hooks","text":"<p>Source: <code>ex_03_custom_classes_json_hooks.py</code></p> <p>Shows how to implement <code>__json_encode__</code> and <code>__json_decode__</code> methods for custom serialization behavior.</p> <pre><code>from typing import Any, Dict\nfrom typing_extensions import override\nfrom kajson import kajson, kajson_manager\n\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n    def __json_encode__(self):\n        \"\"\"Called during serialization\"\"\"\n        return {\"x\": self.x, \"y\": self.y}\n\n    @classmethod\n    def __json_decode__(cls, data: Dict[str, Any]):\n        \"\"\"Called during deserialization\"\"\"\n        return cls(data[\"x\"], data[\"y\"])\n\n    @override\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Point):\n            return False\n        return self.x == other.x and self.y == other.y\n\n    @override\n    def __repr__(self) -&gt; str:\n        return f\"Point(x={self.x}, y={self.y})\"\n\ndef main():\n    # Use it directly\n    point = Point(3.14, 2.71)\n    json_str = kajson.dumps(point)\n    restored = kajson.loads(json_str)\n    assert point == restored\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre>"},{"location":"pages/examples/#registering-custom-type-encoders","title":"Registering Custom Type Encoders","text":"<p>Source: <code>ex_04_registering_custom_encoders.py</code></p> <p>Demonstrates how to register custom encoders and decoders for types like <code>Decimal</code> and <code>Path</code>.</p> <pre><code>from decimal import Decimal\nfrom pathlib import Path\nfrom typing import Any, Dict\nfrom kajson import kajson, kajson_manager\n\ndef main():\n    # Register Decimal support\n    kajson.UniversalJSONEncoder.register(\n        Decimal,\n        lambda d: {\"decimal\": str(d)}\n    )\n    kajson.UniversalJSONDecoder.register(\n        Decimal,\n        lambda data: Decimal(data[\"decimal\"])\n    )\n\n    # Register Path support - handle both abstract and concrete types\n    def encode_path(p: Path) -&gt; Dict[str, Any]:\n        return {\"path\": str(p)}\n\n    def decode_path(data: Dict[str, Any]) -&gt; Path:\n        return Path(data[\"path\"])\n\n    kajson.UniversalJSONEncoder.register(Path, encode_path)\n    kajson.UniversalJSONDecoder.register(Path, decode_path)\n\n    # Also register for the concrete Path type (PosixPath/WindowsPath)\n    concrete_path_type = type(Path())\n    if concrete_path_type != Path:\n        kajson.UniversalJSONEncoder.register(concrete_path_type, encode_path)\n        kajson.UniversalJSONDecoder.register(concrete_path_type, decode_path)\n\n    # Now they work!\n    data = {\n        \"price\": Decimal(\"19.99\"),\n        \"config_path\": Path(\"/etc/app/config.json\")\n    }\n    restored = kajson.loads(kajson.dumps(data))\n    assert restored[\"price\"] == Decimal(\"19.99\")\n    assert isinstance(restored[\"config_path\"], Path)\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre>"},{"location":"pages/examples/#working-with-lists-of-mixed-types","title":"Working with Lists of Mixed Types","text":"<p>Source: <code>ex_05_mixed_types_lists.py</code></p> <p>Shows how Kajson handles heterogeneous lists containing different object types seamlessly.</p> <pre><code>from datetime import date, datetime, time\nfrom pydantic import BaseModel\nfrom kajson import kajson, kajson_manager\n\nclass Task(BaseModel):\n    name: str\n    due_date: date\n\ndef main():\n    # Mix different types in one list\n    mixed_data = [\n        Task(name=\"Review PR\", due_date=date.today()),\n        datetime.now(),\n        {\"plain\": \"dict\"},\n        [\"plain\", \"list\"],\n        time(14, 30),\n    ]\n\n    # Kajson handles everything\n    json_str = kajson.dumps(mixed_data)\n    restored = kajson.loads(json_str)\n\n    # Types are preserved\n    assert isinstance(restored[0], Task)\n    assert isinstance(restored[1], datetime)\n    assert isinstance(restored[4], time)\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre>"},{"location":"pages/examples/#error-handling-with-validation","title":"Error Handling with Validation","text":"<p>Source: <code>ex_06_error_handling_validation.py</code></p> <p>Demonstrates proper error handling when Pydantic validation fails during deserialization.</p> <pre><code>from pydantic import BaseModel, Field\nfrom kajson import kajson, kajson_manager\n\nclass Product(BaseModel):\n    name: str\n    price: float = Field(gt=0)  # Must be positive\n\ndef main():\n    # Valid data works fine\n    product = Product(name=\"Widget\", price=19.99)\n    json_str = kajson.dumps(product)\n    restored = kajson.loads(json_str)\n\n    # Invalid data in JSON\n    invalid_json = '''\n{\n    \"name\": \"Widget\",\n    \"price\": -10,\n    \"__class__\": \"Product\",\n    \"__module__\": \"__main__\"\n}\n'''\n\n    try:\n        kajson.loads(invalid_json)\n    except kajson.KajsonDecoderError:\n        print(\"\u2705 Validation failed as expected!\")\n        # Kajson properly caught the Pydantic validation error\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre>"},{"location":"pages/examples/#drop-in-replacement-usage","title":"Drop-in Replacement Usage","text":"<p>Source: <code>ex_07_drop_in_replacement.py</code></p> <p>Shows how to use Kajson as a direct replacement for Python's standard <code>json</code> module.</p> <pre><code># Simply change your import\nimport kajson as json  # Instead of: import json\nfrom datetime import datetime\nfrom kajson import kajson_manager\n\ndef main():\n    # All your existing code works!\n    data = {\"user\": \"Alice\", \"logged_in\": datetime.now()}\n    json_str = json.dumps(data)  # Works with datetime!\n    restored = json.loads(json_str)\n\n    # Or use kajson directly\n    import kajson\n    json_str2 = kajson.dumps(data)\n    restored2 = kajson.loads(json_str2)\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre>"},{"location":"pages/examples/#pydantic-subclass-polymorphism","title":"Pydantic Subclass Polymorphism","text":"<p>Source: <code>ex_15_pydantic_subclass_polymorphism.py</code></p> <p>Demonstrates Kajson's powerful ability to preserve exact subclass types during serialization, even when fields are declared with base class types. This is perfect for polymorphic APIs, plugin architectures, and complex data modeling.</p> <pre><code>from typing import List\nfrom typing_extensions import override\nfrom pydantic import BaseModel, Field\nfrom kajson import kajson, kajson_manager\n\nclass Animal(BaseModel):\n    \"\"\"Base animal class with common attributes.\"\"\"\n    name: str\n    species: str\n    age: int\n\n    def make_sound(self) -&gt; str:\n        return \"Some generic animal sound\"\n\nclass Dog(Animal):\n    \"\"\"Dog subclass with breed-specific attributes.\"\"\"\n    breed: str\n    is_good_boy: bool = True\n    favorite_toy: str = \"tennis ball\"\n\n    @override\n    def make_sound(self) -&gt; str:\n        return \"Woof! Woof!\"\n\nclass Cat(Animal):\n    \"\"\"Cat subclass with feline-specific attributes.\"\"\"\n    lives_remaining: int = 9\n    is_indoor: bool = True\n    favorite_nap_spot: str = \"sunny windowsill\"\n\n    @override\n    def make_sound(self) -&gt; str:\n        return \"Meow~\"\n\nclass Pet(BaseModel):\n    \"\"\"Pet registration with owner information.\"\"\"\n    owner_name: str\n    animal: Animal  # \u2190 Field declared as base class, but can hold subclass instances\n    registration_date: str\n    veterinarian: str\n\nclass AnimalShelter(BaseModel):\n    \"\"\"Animal shelter with mixed animal types.\"\"\"\n    name: str\n    location: str\n    animals: List[Animal]  # \u2190 List of base class, but can contain subclass instances\n    capacity: int\n\ndef main():\n    # Create pets with different animal subclasses\n    pets = [\n        Pet(\n            owner_name=\"Alice Smith\",\n            animal=Dog(name=\"Buddy\", species=\"Canis lupus\", age=3, breed=\"Golden Retriever\"),\n            registration_date=\"2024-01-15\",\n            veterinarian=\"Dr. Johnson\"\n        ),\n        Pet(\n            owner_name=\"Bob Wilson\",\n            animal=Cat(name=\"Whiskers\", species=\"Felis catus\", age=5, lives_remaining=8),\n            registration_date=\"2024-02-20\",\n            veterinarian=\"Dr. Martinez\"\n        )\n    ]\n\n    # Create shelter with mixed types\n    shelter = AnimalShelter(\n        name=\"Happy Paws Animal Shelter\",\n        location=\"Springfield\",\n        capacity=50,\n        animals=[\n            Dog(name=\"Max\", species=\"Canis lupus\", age=4, breed=\"German Shepherd\"),\n            Cat(name=\"Luna\", species=\"Felis catus\", age=2, lives_remaining=9),\n        ]\n    )\n\n    # Serialize everything\n    pets_json = kajson.dumps(pets, indent=2)\n    shelter_json = kajson.dumps(shelter, indent=2)\n\n    # Deserialize and verify subclass types are preserved\n    restored_pets = kajson.loads(pets_json)\n    restored_shelter = kajson.loads(shelter_json)\n\n    # Subclass types and attributes are perfectly preserved!\n    assert isinstance(restored_pets[0].animal, Dog)  # Still a Dog, not just Animal\n    assert restored_pets[0].animal.breed == \"Golden Retriever\"  # Subclass attributes intact\n    assert restored_pets[0].animal.make_sound() == \"Woof! Woof!\"  # Subclass methods work\n\n    assert isinstance(restored_pets[1].animal, Cat)  # Still a Cat\n    assert restored_pets[1].animal.lives_remaining == 8  # Cat-specific attributes preserved\n    assert restored_pets[1].animal.make_sound() == \"Meow~\"  # Cat methods work\n\n    print(\"\ud83c\udf89 Subclass polymorphism works perfectly!\")\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre> <p>Key Benefits: - \ud83c\udfad Polymorphic APIs - Base class endpoints that handle multiple subclasses - \ud83d\uddc2\ufe0f Mixed collections - Lists of base class containing various subclasses - \ud83c\udfd7\ufe0f Plugin architectures - Runtime-loaded implementations of base interfaces - \ud83d\udcca Data modeling - Complex hierarchies with specialized behaviors</p>"},{"location":"pages/examples/#generic-pydantic-models","title":"Generic Pydantic Models","text":"<p>Source: <code>ex_16_generic_models.py</code></p> <p>Demonstrates comprehensive support for generic Pydantic models with type parameters. Perfect for type-safe containers, APIs, and data structures that need parametric polymorphism.</p> <pre><code>from typing import Dict, Generic, List, Optional, TypeVar, Union\nfrom pydantic import BaseModel\nfrom kajson import kajson, kajson_manager\n\nT = TypeVar(\"T\")\nK = TypeVar(\"K\") \nV = TypeVar(\"V\")\n\nclass Container(BaseModel, Generic[T]):\n    \"\"\"A generic container that can hold any type safely.\"\"\"\n    name: str\n    items: List[T]\n    capacity: int\n\nclass KeyValueStore(BaseModel, Generic[K, V]):\n    \"\"\"A generic key-value store with typed keys and values.\"\"\"\n    name: str\n    data: Dict[K, V]\n    created_by: str\n\nclass ApiResponse(BaseModel, Generic[T]):\n    \"\"\"A generic API response wrapper.\"\"\"\n    success: bool\n    data: Optional[T] = None\n    error: Optional[str] = None\n    timestamp: str\n\ndef main():\n    # Single type parameter\n    string_container = Container[str](\n        name=\"fruits\",\n        items=[\"apple\", \"banana\", \"cherry\"],\n        capacity=10\n    )\n\n    # Multiple type parameters\n    scores = KeyValueStore[str, int](\n        name=\"user_scores\",\n        data={\"alice\": 95, \"bob\": 87},\n        created_by=\"admin\"\n    )\n\n    # Nested generics\n    response = ApiResponse[List[Product]](\n        success=True,\n        data=[Product(name=\"Widget\", price=19.99)],\n        timestamp=\"2025-01-15T10:30:00Z\"\n    )\n\n    # All serialize and deserialize perfectly!\n    containers_json = kajson.dumps([string_container, scores, response])\n    restored = kajson.loads(containers_json)\n\n    # Type information is preserved\n    assert isinstance(restored[0], Container)  # Container[str]\n    assert isinstance(restored[1], KeyValueStore)  # KeyValueStore[str, int]\n    assert isinstance(restored[2], ApiResponse)  # ApiResponse[List[Product]]\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre> <p>Key Features: - \ud83c\udfd7\ufe0f Single type parameters - <code>Container[T]</code> for type-safe collections - \u2699\ufe0f Multiple parameters - <code>KeyValueStore[K, V]</code> for complex relationships - \ud83d\udd17 Nested generics - <code>ApiResponse[List[Product]]</code> for API patterns - \ud83c\udfaf Bounded types - <code>Calculator[NumericType]</code> with type constraints - \u2728 Perfect preservation - All type information maintained during roundtrip</p>"},{"location":"pages/examples/#polymorphism-with-enums","title":"Polymorphism with Enums","text":"<p>Source: <code>ex_17_polymorphism_with_enums.py</code></p> <p>Demonstrates how Kajson perfectly handles polymorphism combined with enum fields. Shows that subclass types and enum values are both preserved during serialization, making it ideal for complex data models with categorical attributes.</p> <pre><code>from datetime import datetime\nfrom enum import Enum\nfrom pydantic import BaseModel\nfrom typing_extensions import override\nfrom kajson import kajson, kajson_manager\n\nclass Personality(Enum):\n    \"\"\"Enum representing different cat personalities.\"\"\"\n    PLAYFUL = \"playful\"\n    GRUMPY = \"grumpy\"\n    CUDDLY = \"cuddly\"\n\nclass Animal(BaseModel):\n    \"\"\"Base animal class with common attributes.\"\"\"\n    name: str\n\n    def get_description(self) -&gt; str:\n        return f\"Animal named {self.name}\"\n\nclass Dog(Animal):\n    \"\"\"Dog subclass with breed-specific attributes.\"\"\"\n    breed: str\n\n    @override\n    def get_description(self) -&gt; str:\n        return f\"Dog named {self.name} ({self.breed} breed)\"\n\nclass Cat(Animal):\n    \"\"\"Cat subclass with feline-specific attributes including personality enum.\"\"\"\n    indoor: bool\n    personality: Personality\n\n    @override\n    def get_description(self) -&gt; str:\n        indoor_status = \"indoor\" if self.indoor else \"outdoor\"\n        return f\"Cat named {self.name} ({indoor_status}, {self.personality.value} personality)\"\n\nclass Pet(BaseModel):\n    \"\"\"Pet registration with acquisition date and animal reference.\"\"\"\n    acquired: datetime\n    animal: Animal  # \u2190 Field declared as base class, but can hold subclass instances\n\ndef main():\n    # Create instances with different subclasses\n    fido = Pet(\n        acquired=datetime.now(),\n        animal=Dog(name=\"Fido\", breed=\"Corgi\")\n    )\n\n    whiskers = Pet(\n        acquired=datetime.now(),\n        animal=Cat(name=\"Whiskers\", indoor=True, personality=Personality.GRUMPY)\n    )\n\n    # Serialize to JSON\n    whiskers_json = kajson.dumps(whiskers, indent=2)\n\n    # Deserialize back\n    whiskers_restored = kajson.loads(whiskers_json)\n\n    # Verify subclass and enum preservation\n    assert isinstance(whiskers_restored.animal, Cat)  # \u2705 Still a Cat, not just Animal\n    assert whiskers_restored.animal.personality == Personality.GRUMPY  # \u2705 Enum preserved\n    assert whiskers_restored.animal.indoor is True  # \u2705 All attributes intact\n\n    print(\"\ud83c\udf89 SUCCESS: Polymorphism and enum preservation works perfectly!\")\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre> <p>Key Benefits: - \ud83c\udfad Enum preservation - Enum values and types are perfectly maintained - \ud83d\udd04 Subclass polymorphism - Base class fields can hold specific subclasses - \ud83d\udcca Complex data models - Ideal for domain models with categorical attributes - \u2728 Perfect reconstruction - All type information and enum values preserved</p>"},{"location":"pages/examples/#dynamic-class-registry","title":"Dynamic Class Registry","text":"<p>Source: <code>ex_14_dynamic_class_registry.py</code></p> <p>Shows when and how to use the class registry for dynamically created classes that aren't available in standard module paths. Essential for distributed systems and runtime class generation.</p> <pre><code>from kajson import kajson, kajson_manager\nfrom kajson.kajson_manager import KajsonManager\n\ndef main():\n    # Simulate dynamic class creation (e.g., from network, workflow definition)\n    remote_class_definition = '''\nfrom pydantic import BaseModel, Field\n\nclass RemoteTask(BaseModel):\n    task_id: str\n    name: str  \n    priority: int = Field(default=1, ge=1, le=10)\n'''\n\n    # Execute and create the class dynamically\n    remote_namespace = {}\n    exec(remote_class_definition, remote_namespace)\n    RemoteTask = remote_namespace[\"RemoteTask\"]\n\n    # Set module to simulate it's not available locally\n    RemoteTask.__module__ = \"remote.distributed.system\"\n\n    # Create and serialize\n    task = RemoteTask(task_id=\"TASK_001\", name=\"Process Data\", priority=5)\n    json_str = kajson.dumps(task)\n\n    # Clear local definition (simulate distributed scenario)\n    del remote_namespace[\"RemoteTask\"]\n\n    # Register in class registry for deserialization\n    registry = KajsonManager.get_class_registry()\n    registry.register_class(RemoteTask)\n\n    # Now deserialization works via class registry!\n    restored_task = kajson.loads(json_str)\n    assert restored_task.task_id == \"TASK_001\"\n\nif __name__ == \"__main__\":\n    kajson_manager.KajsonManager()\n    main()\n</code></pre>"},{"location":"pages/examples/#additional-examples","title":"Additional Examples","text":"<p>The <code>examples/</code> directory contains additional examples:</p> <ul> <li>README Examples (<code>ex_08_readme_basic_usage.py</code> - <code>ex_13_readme_error_handling.py</code>): Examples used in the project README with detailed explanations and comparisons with standard JSON</li> <li>Complex Nested Models (<code>ex_09_readme_complex_nested.py</code>): More complex nesting scenarios with metadata</li> <li>Advanced Custom Registration (<code>ex_10_readme_custom_registration.py</code>): Detailed custom type registration examples</li> <li>Custom Hooks Variations (<code>ex_11_readme_custom_hooks.py</code>): Alternative implementations of custom JSON hooks</li> </ul>"},{"location":"pages/examples/#running-the-examples","title":"Running the Examples","text":"<p>To run any example:</p> <pre><code>cd examples\npython ex_01_basic_pydantic_serialization.py\n</code></pre> <p>All examples are self-contained and demonstrate different aspects of Kajson's capabilities. Each file includes detailed comments explaining the concepts being demonstrated.</p>"},{"location":"pages/guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers the fundamental features of Kajson and how to use it as a drop-in replacement for Python's standard <code>json</code> module.</p>"},{"location":"pages/guide/basic-usage/#importing-kajson","title":"Importing Kajson","text":"<p>You can import Kajson in two ways:</p> <pre><code># Option 1: Direct import\nimport kajson\n\n# Option 2: Drop-in replacement\nimport kajson as json\n</code></pre>"},{"location":"pages/guide/basic-usage/#basic-serialization-and-deserialization","title":"Basic Serialization and Deserialization","text":""},{"location":"pages/guide/basic-usage/#simple-data-types","title":"Simple Data Types","text":"<p>Kajson handles all standard JSON data types just like the standard <code>json</code> module:</p> <pre><code>import kajson\n\n# Basic types\ndata = {\n    \"string\": \"Hello, World!\",\n    \"number\": 42,\n    \"float\": 3.14159,\n    \"boolean\": True,\n    \"null\": None,\n    \"list\": [1, 2, 3],\n    \"dict\": {\"nested\": \"value\"}\n}\n\n# Serialize to JSON string\njson_str = kajson.dumps(data)\n\n# Deserialize back to Python object\nrestored = kajson.loads(json_str)\n\nassert data == restored  # Perfect reconstruction\n</code></pre>"},{"location":"pages/guide/basic-usage/#formatting-options","title":"Formatting Options","text":"<p>Kajson supports all the standard formatting options:</p> <pre><code>import kajson\n\ndata = {\"name\": \"Alice\", \"age\": 30, \"skills\": [\"Python\", \"JavaScript\"]}\n\n# Pretty printing with indentation\nprint(kajson.dumps(data, indent=2))\n\n# Compact output without spaces\nprint(kajson.dumps(data, separators=(',', ':')))\n\n# Sort keys alphabetically\nprint(kajson.dumps(data, sort_keys=True))\n\n# Combine options\nprint(kajson.dumps(data, indent=4, sort_keys=True))\n</code></pre>"},{"location":"pages/guide/basic-usage/#working-with-files","title":"Working with Files","text":""},{"location":"pages/guide/basic-usage/#writing-json-to-files","title":"Writing JSON to Files","text":"<pre><code>import kajson\n\ndata = {\n    \"users\": [\n        {\"id\": 1, \"name\": \"Alice\"},\n        {\"id\": 2, \"name\": \"Bob\"}\n    ],\n    \"total\": 2\n}\n\n# Write to file\nwith open(\"data.json\", \"w\") as f:\n    kajson.dump(data, f, indent=2)\n\n# Alternative: dumps then write\njson_str = kajson.dumps(data, indent=2)\nwith open(\"data2.json\", \"w\") as f:\n    f.write(json_str)\n</code></pre>"},{"location":"pages/guide/basic-usage/#reading-json-from-files","title":"Reading JSON from Files","text":"<pre><code>import kajson\n\n# Read from file\nwith open(\"data.json\", \"r\") as f:\n    data = kajson.load(f)\n\n# Alternative: read then loads\nwith open(\"data.json\", \"r\") as f:\n    json_str = f.read()\n    data = kajson.loads(json_str)\n</code></pre>"},{"location":"pages/guide/basic-usage/#enhanced-type-support","title":"Enhanced Type Support","text":"<p>Unlike standard <code>json</code>, Kajson automatically handles many Python types:</p>"},{"location":"pages/guide/basic-usage/#datetime-objects","title":"DateTime Objects","text":"<pre><code>import kajson\nfrom datetime import datetime, date, time, timedelta\n\ndata = {\n    \"created_at\": datetime.now(),\n    \"date_only\": date.today(),\n    \"time_only\": time(14, 30, 45),\n    \"duration\": timedelta(days=7, hours=3)\n}\n\n# Serialize and deserialize\njson_str = kajson.dumps(data)\nrestored = kajson.loads(json_str)\n\n# Types are preserved!\nassert isinstance(restored[\"created_at\"], datetime)\nassert isinstance(restored[\"duration\"], timedelta)\n</code></pre>"},{"location":"pages/guide/basic-usage/#lists-and-dictionaries-with-complex-types","title":"Lists and Dictionaries with Complex Types","text":"<pre><code>import kajson\nfrom datetime import datetime\n\n# Complex nested structures\ndata = {\n    \"timestamps\": [datetime.now(), datetime(2025, 1, 1)],\n    \"events\": {\n        \"start\": datetime(2025, 1, 1, 9, 0),\n        \"end\": datetime(2025, 1, 1, 17, 0)\n    }\n}\n\n# Works seamlessly\njson_str = kajson.dumps(data)\nrestored = kajson.loads(json_str)\n\n# All nested types preserved\nfor ts in restored[\"timestamps\"]:\n    assert isinstance(ts, datetime)\n</code></pre>"},{"location":"pages/guide/basic-usage/#advanced-options","title":"Advanced Options","text":""},{"location":"pages/guide/basic-usage/#custom-separators","title":"Custom Separators","text":"<pre><code>import kajson\n\ndata = {\"a\": 1, \"b\": 2}\n\n# Default separators\ndefault = kajson.dumps(data)\nprint(default)  # {\"a\": 1, \"b\": 2}\n\n# Custom separators for compact output\ncompact = kajson.dumps(data, separators=(',', ':'))\nprint(compact)  # {\"a\":1,\"b\":2}\n\n# Custom separators with spaces\nspaced = kajson.dumps(data, separators=(', ', ': '))\nprint(spaced)  # {\"a\": 1, \"b\": 2}\n</code></pre>"},{"location":"pages/guide/basic-usage/#ensure-ascii","title":"Ensure ASCII","text":"<pre><code>import kajson\n\ndata = {\"greeting\": \"Hello \u4e16\u754c \ud83c\udf0d\"}\n\n# Default: UTF-8 characters preserved\nutf8 = kajson.dumps(data)\nprint(utf8)  # {\"greeting\": \"Hello \u4e16\u754c \ud83c\udf0d\"}\n\n# Ensure ASCII: escape non-ASCII characters\nascii_only = kajson.dumps(data, ensure_ascii=True)\nprint(ascii_only)  # {\"greeting\": \"Hello \\\\u4e16\\\\u754c \\\\ud83c\\\\udf0d\"}\n</code></pre>"},{"location":"pages/guide/basic-usage/#streaming-large-data","title":"Streaming Large Data","text":"<p>For large datasets, you can use generators and iterative parsing:</p> <pre><code>import kajson\n\n# Serialize large data in chunks\ndef generate_large_data():\n    for i in range(1000000):\n        yield {\"id\": i, \"value\": i * 2}\n\n# Write to file efficiently\nwith open(\"large_data.json\", \"w\") as f:\n    f.write(\"[\")\n    for i, item in enumerate(generate_large_data()):\n        if i &gt; 0:\n            f.write(\",\")\n        f.write(kajson.dumps(item))\n    f.write(\"]\")\n</code></pre>"},{"location":"pages/guide/basic-usage/#common-patterns","title":"Common Patterns","text":""},{"location":"pages/guide/basic-usage/#configuration-files","title":"Configuration Files","text":"<pre><code>import kajson\nfrom pathlib import Path\n\nclass Config:\n    def __init__(self, config_path=\"config.json\"):\n        self.path = Path(config_path)\n        self.data = self.load()\n\n    def load(self):\n        if self.path.exists():\n            with open(self.path, \"r\") as f:\n                return kajson.load(f)\n        return {}\n\n    def save(self):\n        with open(self.path, \"w\") as f:\n            kajson.dump(self.data, f, indent=2)\n\n    def get(self, key, default=None):\n        return self.data.get(key, default)\n\n    def set(self, key, value):\n        self.data[key] = value\n        self.save()\n\n# Usage\nconfig = Config()\nconfig.set(\"api_key\", \"secret123\")\nconfig.set(\"timeout\", 30)\n</code></pre>"},{"location":"pages/guide/basic-usage/#api-responses","title":"API Responses","text":"<pre><code>import kajson\n\ndef create_api_response(data, status=\"success\", message=None):\n    response = {\n        \"status\": status,\n        \"timestamp\": kajson.dumps(datetime.now()),  # Will be properly serialized\n        \"data\": data\n    }\n    if message:\n        response[\"message\"] = message\n\n    return kajson.dumps(response, indent=2)\n\n# Usage\nuser_data = {\"id\": 123, \"name\": \"Alice\"}\nresponse = create_api_response(user_data)\nprint(response)\n</code></pre>"},{"location":"pages/guide/basic-usage/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always use context managers when working with files:    <pre><code>with open(\"file.json\", \"r\") as f:\n    data = kajson.load(f)\n</code></pre></p> </li> <li> <p>Handle exceptions when loading untrusted data:    <pre><code>try:\n    data = kajson.loads(user_input)\nexcept kajson.JSONDecodeError as e:\n    print(f\"Invalid JSON: {e}\")\n</code></pre></p> </li> <li> <p>Use appropriate formatting for your use case:</p> </li> <li>Human-readable: <code>indent=2</code> or <code>indent=4</code></li> <li>Network transmission: <code>separators=(',', ':')</code> for compact output</li> <li>Configuration files: <code>indent=2, sort_keys=True</code> for consistency</li> </ol>"},{"location":"pages/guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Pydantic Integration for working with data models</li> <li>Explore Custom Types to extend Kajson's capabilities</li> <li>See Error Handling for robust error management </li> </ul>"},{"location":"pages/guide/class-registry/","title":"Class Registry","text":"<p>The Class Registry is a powerful feature in kajson that solves a critical problem: deserializing classes that aren't available in the standard module path. This is essential for distributed systems, dynamic class generation, and other advanced scenarios.</p>"},{"location":"pages/guide/class-registry/#overview","title":"Overview","text":"<p>When kajson deserializes a JSON string containing class metadata (<code>__class__</code> and <code>__module__</code>), it needs to locate and instantiate the appropriate class. By default, it:</p> <ol> <li>Checks if the module is already imported</li> <li>Attempts to import the module dynamically</li> <li>Retrieves the class from the module</li> </ol> <p>However, this approach fails when:</p> <ul> <li>Classes are created dynamically at runtime</li> <li>Classes come from remote systems or distributed services</li> <li>Module paths don't exist in the current environment</li> <li>Classes are generated from workflow definitions or configurations</li> </ul> <p>The Class Registry provides a solution by maintaining a centralized registry of classes that can be looked up by name during deserialization.</p>"},{"location":"pages/guide/class-registry/#when-to-use-the-class-registry","title":"When to Use the Class Registry","text":"<p>You need the Class Registry when dealing with:</p> <ul> <li>\ud83c\udf10 Distributed Systems: Classes defined in different services or microservices</li> <li>\ud83d\udd04 Dynamic Class Generation: Classes created at runtime from configurations or definitions</li> <li>\ud83e\udde9 Plugin Systems: Dynamically loaded plugins with custom classes</li> <li>\ud83d\udcca Workflow Orchestrators: Task definitions created from workflow specifications</li> <li>\ud83d\udd0c Remote APIs: Classes received over the network that need to be reconstructed locally</li> <li>\u26a1 Runtime Type Systems: Classes that don't exist until runtime</li> </ul>"},{"location":"pages/guide/class-registry/#basic-usage","title":"Basic Usage","text":""},{"location":"pages/guide/class-registry/#getting-the-registry","title":"Getting the Registry","text":"<p>The class registry is managed by the <code>KajsonManager</code> singleton:</p> <pre><code>from kajson.kajson_manager import KajsonManager\n\n# Get the global class registry\nregistry = KajsonManager.get_class_registry()\n</code></pre>"},{"location":"pages/guide/class-registry/#registering-classes","title":"Registering Classes","text":""},{"location":"pages/guide/class-registry/#register-a-single-class","title":"Register a Single Class","text":"<pre><code>from pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    name: str\n    value: int\n\n# Register with default name (class name)\nregistry.register_class(MyModel)\n\n# Register with custom name\nregistry.register_class(MyModel, \"CustomModelName\")\n</code></pre>"},{"location":"pages/guide/class-registry/#register-multiple-classes","title":"Register Multiple Classes","text":"<pre><code># Register as a list (uses class names)\nregistry.register_classes([Model1, Model2, Model3])\n\n# Register as a dictionary (custom names)\nregistry.register_classes_dict({\n    \"FirstModel\": Model1,\n    \"SecondModel\": Model2,\n    \"ThirdModel\": Model3\n})\n</code></pre>"},{"location":"pages/guide/class-registry/#retrieving-classes","title":"Retrieving Classes","text":"<pre><code># Get a class (returns None if not found)\nmodel_class = registry.get_class(\"MyModel\")\n\n# Get a required class (raises exception if not found)\nmodel_class = registry.get_required_class(\"MyModel\")\n\n# Get a required subclass (with type checking)\nmodel_class = registry.get_required_subclass(\"MyModel\", BaseModel)\n\n# Get a required BaseModel\nmodel_class = registry.get_required_base_model(\"MyModel\")\n</code></pre>"},{"location":"pages/guide/class-registry/#checking-class-existence","title":"Checking Class Existence","text":"<pre><code># Check if a class exists\nif registry.has_class(\"MyModel\"):\n    print(\"MyModel is registered\")\n\n# Check if a subclass exists\nif registry.has_subclass(\"MyModel\", BaseModel):\n    print(\"MyModel is a registered BaseModel\")\n</code></pre>"},{"location":"pages/guide/class-registry/#unregistering-classes","title":"Unregistering Classes","text":"<pre><code># Unregister by class type\nregistry.unregister_class(MyModel)\n\n# Unregister by name\nregistry.unregister_class_by_name(\"MyModel\")\n\n# Clear all registrations\nregistry.teardown()\n</code></pre>"},{"location":"pages/guide/class-registry/#complete-example-dynamic-class-from-remote-system","title":"Complete Example: Dynamic Class from Remote System","text":"<p>Here's a real-world example showing how the class registry enables deserialization of dynamically created classes:</p> <pre><code>from typing import Optional, Dict, Any\nfrom pydantic import BaseModel, Field\nfrom kajson import kajson\nfrom kajson.kajson_manager import KajsonManager\nfrom kajson.exceptions import KajsonDecoderError\n\n# Simulate receiving a class definition from a remote system\nremote_class_definition = '''\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, Dict, Any\n\nclass RemoteTask(BaseModel):\n    \"\"\"A task definition received from a distributed system.\"\"\"\n    task_id: str = Field(..., description=\"Unique task identifier\")\n    name: str = Field(..., description=\"Task name\")\n    priority: int = Field(default=1, ge=1, le=10, description=\"Task priority\")\n    payload: Optional[Dict[str, Any]] = Field(default=None, description=\"Task payload\")\n\n    def get_info(self) -&gt; str:\n        return f\"Task {self.task_id}: {self.name} (priority: {self.priority})\"\n'''\n\n# Execute the remote class definition\nremote_namespace: Dict[str, Any] = {}\nexec(remote_class_definition, remote_namespace)\nRemoteTask = remote_namespace[\"RemoteTask\"]\n\n# Set module to simulate it's not available locally\nRemoteTask.__module__ = \"remote.distributed.system\"\n\n# Create and serialize a task instance\ntask = RemoteTask(\n    task_id=\"TASK_001\",\n    name=\"Process Data Pipeline\",\n    priority=5,\n    payload={\"input_file\": \"data.csv\", \"output_format\": \"parquet\"}\n)\n\n# Serialize the task\njson_str = kajson.dumps(task)\nprint(f\"Serialized: {json_str[:100]}...\")\n\n# Clear the local class definition (simulate distributed scenario)\ndel remote_namespace[\"RemoteTask\"]\n\n# Without registry, deserialization fails\ntry:\n    kajson.loads(json_str)\nexcept KajsonDecoderError as e:\n    print(f\"Expected failure: {e}\")\n\n# Register the class in the registry\nregistry = KajsonManager.get_class_registry()\nregistry.register_class(RemoteTask)\n\n# Now deserialization works!\nrestored_task = kajson.loads(json_str)\nprint(f\"Restored: {restored_task.get_info()}\")\nprint(f\"Payload: {restored_task.payload}\")\n\n# Clean up\nregistry.teardown()\n</code></pre>"},{"location":"pages/guide/class-registry/#advanced-usage","title":"Advanced Usage","text":""},{"location":"pages/guide/class-registry/#custom-registry-implementation","title":"Custom Registry Implementation","text":"<p>You can create a custom registry by implementing the <code>ClassRegistryAbstract</code> interface:</p> <pre><code>from kajson.class_registry_abstract import ClassRegistryAbstract\nfrom typing import Type, Any, Optional, Dict, List\nfrom pydantic import BaseModel\n\nclass CustomRegistry(ClassRegistryAbstract):\n    def __init__(self):\n        self._classes: Dict[str, Type[Any]] = {}\n\n    def setup(self) -&gt; None:\n        \"\"\"Initialize the registry.\"\"\"\n        pass\n\n    def teardown(self) -&gt; None:\n        \"\"\"Clear all registered classes.\"\"\"\n        self._classes.clear()\n\n    def register_class(\n        self,\n        class_type: Type[Any],\n        name: Optional[str] = None,\n        should_warn_if_already_registered: bool = True\n    ) -&gt; None:\n        \"\"\"Register a single class.\"\"\"\n        key = name or class_type.__name__\n        self._classes[key] = class_type\n\n    # Implement other required methods...\n</code></pre>"},{"location":"pages/guide/class-registry/#using-with-microservices","title":"Using with Microservices","text":"<p>Example of using the class registry in a microservices architecture:</p> <pre><code># Service A - Defines models\nclass OrderModel(BaseModel):\n    order_id: str\n    customer_id: str\n    items: List[Dict[str, Any]]\n    total: float\n\n# Service B - Receives serialized orders\ndef process_order(order_json: str):\n    # Register the model from Service A\n    registry = KajsonManager.get_class_registry()\n    registry.register_class(OrderModel)\n\n    # Deserialize the order\n    order = kajson.loads(order_json)\n\n    # Process the order\n    print(f\"Processing order {order.order_id} for customer {order.customer_id}\")\n    print(f\"Total: ${order.total}\")\n</code></pre>"},{"location":"pages/guide/class-registry/#plugin-system-example","title":"Plugin System Example","text":"<pre><code># Plugin system that loads classes dynamically\nclass PluginRegistry:\n    def __init__(self):\n        self.kajson_registry = KajsonManager.get_class_registry()\n\n    def load_plugin(self, plugin_code: str, plugin_name: str):\n        # Execute plugin code to get classes\n        plugin_namespace = {}\n        exec(plugin_code, plugin_namespace)\n\n        # Register all BaseModel classes from the plugin\n        for name, obj in plugin_namespace.items():\n            if isinstance(obj, type) and issubclass(obj, BaseModel):\n                # Ensure unique module name for the plugin\n                obj.__module__ = f\"plugins.{plugin_name}\"\n                self.kajson_registry.register_class(obj, f\"{plugin_name}.{name}\")\n\n    def serialize_plugin_data(self, data: BaseModel) -&gt; str:\n        return kajson.dumps(data)\n\n    def deserialize_plugin_data(self, json_str: str) -&gt; BaseModel:\n        # The registry will handle finding the right class\n        return kajson.loads(json_str)\n</code></pre>"},{"location":"pages/guide/class-registry/#best-practices","title":"Best Practices","text":"<ol> <li>Clear Naming: Use descriptive names when registering classes to avoid conflicts</li> <li>Module Simulation: Set meaningful <code>__module__</code> values for dynamic classes</li> <li>Cleanup: Use <code>teardown()</code> to clear registrations when appropriate</li> <li>Error Handling: Always handle <code>KajsonDecoderError</code> when deserializing</li> <li>Type Safety: Use <code>get_required_subclass()</code> to ensure type safety</li> </ol>"},{"location":"pages/guide/class-registry/#error-handling","title":"Error Handling","text":"<p>The class registry raises specific exceptions:</p> <ul> <li><code>ClassRegistryNotFoundError</code>: When a required class is not found</li> <li><code>ClassRegistryInheritanceError</code>: When a class doesn't match expected inheritance</li> </ul>"},{"location":"pages/guide/class-registry/#integration-with-kajson","title":"Integration with kajson","text":"<p>The class registry is automatically checked during deserialization:</p> <ol> <li>kajson first checks if the module is already imported</li> <li>If not found, it checks the class registry</li> <li>If still not found, it attempts to import the module</li> <li>If import fails, a <code>KajsonDecoderError</code> is raised</li> </ol> <p>This seamless integration means you only need to register your classes once, and kajson handles the rest automatically.</p>"},{"location":"pages/guide/class-registry/#see-also","title":"See Also","text":"<ul> <li>Basic Usage Guide - Learn the fundamentals of kajson</li> <li>Custom Types Guide - Handle custom types with encoders/decoders</li> <li>API Reference - Complete API documentation</li> <li>Example: Dynamic Class Registry - Full working example</li> </ul>"},{"location":"pages/guide/custom-types/","title":"Custom Types","text":"<p>Learn how to extend Kajson to support any custom type through registration or built-in hooks.</p>"},{"location":"pages/guide/custom-types/#registration-system","title":"Registration System","text":""},{"location":"pages/guide/custom-types/#basic-registration","title":"Basic Registration","text":"<p>The simplest way to add support for a custom type is through the registration system:</p> <pre><code>import kajson\nfrom decimal import Decimal\n\n# Register encoder\ndef encode_decimal(value: Decimal) -&gt; dict:\n    return {\"__decimal__\": str(value)}\n\n# Register decoder\ndef decode_decimal(data: dict) -&gt; Decimal:\n    return Decimal(data[\"__decimal__\"])\n\n# Register both\nkajson.UniversalJSONEncoder.register(Decimal, encode_decimal)\nkajson.UniversalJSONDecoder.register(Decimal, decode_decimal)\n\n# Now Decimal works seamlessly\ndata = {\"price\": Decimal(\"19.99\"), \"tax\": Decimal(\"1.50\")}\njson_str = kajson.dumps(data)\nrestored = kajson.loads(json_str)\n\nassert restored[\"price\"] == Decimal(\"19.99\")\nassert isinstance(restored[\"price\"], Decimal)\n</code></pre>"},{"location":"pages/guide/custom-types/#registration-with-type-checking","title":"Registration with Type Checking","text":"<p>For more robust implementations, include type checking:</p> <pre><code>import kajson\nfrom pathlib import Path\n\ndef encode_path(path: Path) -&gt; dict:\n    return {\n        \"__path__\": str(path),\n        \"is_absolute\": path.is_absolute()\n    }\n\ndef decode_path(data: dict) -&gt; Path:\n    if \"__path__\" not in data:\n        raise ValueError(\"Invalid Path data\")\n    return Path(data[\"__path__\"])\n\nkajson.UniversalJSONEncoder.register(Path, encode_path)\nkajson.UniversalJSONDecoder.register(Path, decode_path)\n\n# Usage\nconfig = {\n    \"project_root\": Path(\"/home/user/project\"),\n    \"config_file\": Path(\"config/settings.json\")\n}\n\njson_str = kajson.dumps(config)\nrestored = kajson.loads(json_str)\n</code></pre>"},{"location":"pages/guide/custom-types/#custom-class-hooks","title":"Custom Class Hooks","text":""},{"location":"pages/guide/custom-types/#using-json_encode-and-json_decode","title":"Using json_encode and json_decode","text":"<p>Classes can define their own serialization behavior:</p> <pre><code>import kajson\nfrom typing import Tuple\n\nclass Color:\n    def __init__(self, r: int, g: int, b: int, name: str = \"\"):\n        self.r = r\n        self.g = g\n        self.b = b\n        self.name = name\n\n    def __json_encode__(self) -&gt; dict:\n        \"\"\"Called by Kajson during serialization\"\"\"\n        return {\n            \"rgb\": (self.r, self.g, self.b),\n            \"name\": self.name,\n            \"hex\": f\"#{self.r:02x}{self.g:02x}{self.b:02x}\"\n        }\n\n    @classmethod\n    def __json_decode__(cls, data: dict) -&gt; \"Color\":\n        \"\"\"Called by Kajson during deserialization\"\"\"\n        r, g, b = data[\"rgb\"]\n        return cls(r, g, b, data.get(\"name\", \"\"))\n\n    def __eq__(self, other):\n        return (self.r, self.g, self.b, self.name) == (other.r, other.g, other.b, other.name)\n\n# Works automatically\nred = Color(255, 0, 0, \"red\")\njson_str = kajson.dumps(red)\nrestored = kajson.loads(json_str)\n\nassert red == restored\n</code></pre>"},{"location":"pages/guide/custom-types/#complex-custom-types","title":"Complex Custom Types","text":"<pre><code>import kajson\nfrom typing import List, Optional\nimport numpy as np\n\nclass Matrix:\n    def __init__(self, data: List[List[float]]):\n        self.data = np.array(data)\n        self.shape = self.data.shape\n\n    def __json_encode__(self) -&gt; dict:\n        return {\n            \"data\": self.data.tolist(),\n            \"shape\": self.shape,\n            \"dtype\": str(self.data.dtype)\n        }\n\n    @classmethod\n    def __json_decode__(cls, data: dict) -&gt; \"Matrix\":\n        return cls(data[\"data\"])\n\n    def __eq__(self, other):\n        return np.array_equal(self.data, other.data)\n\n# Usage\nmatrix = Matrix([[1, 2, 3], [4, 5, 6]])\njson_str = kajson.dumps(matrix)\nrestored = kajson.loads(json_str)\n\nassert matrix == restored\n</code></pre>"},{"location":"pages/guide/custom-types/#advanced-registration-patterns","title":"Advanced Registration Patterns","text":""},{"location":"pages/guide/custom-types/#registering-multiple-types-at-once","title":"Registering Multiple Types at Once","text":"<pre><code>import kajson\nfrom fractions import Fraction\nfrom ipaddress import IPv4Address, IPv6Address\n\n# Define encoders/decoders\ntype_handlers = {\n    Fraction: {\n        \"encode\": lambda f: {\"num\": f.numerator, \"den\": f.denominator},\n        \"decode\": lambda d: Fraction(d[\"num\"], d[\"den\"])\n    },\n    IPv4Address: {\n        \"encode\": lambda ip: {\"ipv4\": str(ip)},\n        \"decode\": lambda d: IPv4Address(d[\"ipv4\"])\n    },\n    IPv6Address: {\n        \"encode\": lambda ip: {\"ipv6\": str(ip)},\n        \"decode\": lambda d: IPv6Address(d[\"ipv6\"])\n    }\n}\n\n# Register all at once\nfor type_class, handlers in type_handlers.items():\n    kajson.UniversalJSONEncoder.register(type_class, handlers[\"encode\"])\n    kajson.UniversalJSONDecoder.register(type_class, handlers[\"decode\"])\n\n# All types now work\ndata = {\n    \"fraction\": Fraction(3, 4),\n    \"ipv4\": IPv4Address(\"192.168.1.1\"),\n    \"ipv6\": IPv6Address(\"2001:db8::1\")\n}\n\njson_str = kajson.dumps(data)\nrestored = kajson.loads(json_str)\n</code></pre>"},{"location":"pages/guide/custom-types/#conditional-registration","title":"Conditional Registration","text":"<pre><code>import kajson\nimport platform\n\n# Register platform-specific types\nif platform.system() == \"Windows\":\n    from pathlib import WindowsPath\n\n    kajson.UniversalJSONEncoder.register(\n        WindowsPath,\n        lambda p: {\"windows_path\": str(p)}\n    )\n    kajson.UniversalJSONDecoder.register(\n        WindowsPath,\n        lambda d: WindowsPath(d[\"windows_path\"])\n    )\n</code></pre>"},{"location":"pages/guide/custom-types/#working-with-third-party-libraries","title":"Working with Third-Party Libraries","text":""},{"location":"pages/guide/custom-types/#numpy-arrays","title":"NumPy Arrays","text":"<pre><code>import kajson\nimport numpy as np\n\ndef encode_ndarray(arr: np.ndarray) -&gt; dict:\n    return {\n        \"data\": arr.tolist(),\n        \"dtype\": str(arr.dtype),\n        \"shape\": arr.shape\n    }\n\ndef decode_ndarray(data: dict) -&gt; np.ndarray:\n    arr = np.array(data[\"data\"], dtype=data[\"dtype\"])\n    return arr.reshape(data[\"shape\"])\n\nkajson.UniversalJSONEncoder.register(np.ndarray, encode_ndarray)\nkajson.UniversalJSONDecoder.register(np.ndarray, decode_ndarray)\n\n# Usage\ndata = {\n    \"matrix\": np.array([[1, 2], [3, 4]]),\n    \"vector\": np.array([1.0, 2.0, 3.0])\n}\n\njson_str = kajson.dumps(data)\nrestored = kajson.loads(json_str)\n\nassert np.array_equal(data[\"matrix\"], restored[\"matrix\"])\n</code></pre>"},{"location":"pages/guide/custom-types/#pandas-dataframes","title":"Pandas DataFrames","text":"<pre><code>import kajson\nimport pandas as pd\n\ndef encode_dataframe(df: pd.DataFrame) -&gt; dict:\n    return {\n        \"data\": df.to_dict(orient=\"records\"),\n        \"columns\": df.columns.tolist(),\n        \"index\": df.index.tolist()\n    }\n\ndef decode_dataframe(data: dict) -&gt; pd.DataFrame:\n    df = pd.DataFrame(data[\"data\"])\n    df.index = data[\"index\"]\n    return df[data[\"columns\"]]  # Preserve column order\n\nkajson.UniversalJSONEncoder.register(pd.DataFrame, encode_dataframe)\nkajson.UniversalJSONDecoder.register(pd.DataFrame, decode_dataframe)\n\n# Usage\ndf = pd.DataFrame({\n    \"name\": [\"Alice\", \"Bob\", \"Carol\"],\n    \"age\": [25, 30, 35],\n    \"city\": [\"NYC\", \"LA\", \"Chicago\"]\n})\n\njson_str = kajson.dumps(df)\nrestored = kajson.loads(json_str)\n\nassert df.equals(restored)\n</code></pre>"},{"location":"pages/guide/custom-types/#best-practices","title":"Best Practices","text":""},{"location":"pages/guide/custom-types/#1-use-unique-keys","title":"1. Use Unique Keys","text":"<p>Always use unique keys in your encoded data to avoid conflicts:</p> <pre><code># Good - unique key unlikely to conflict\ndef encode_custom(value):\n    return {\"__mylib_custom__\": value.data}\n\n# Bad - generic key might conflict\ndef encode_custom(value):\n    return {\"data\": value.data}\n</code></pre>"},{"location":"pages/guide/custom-types/#2-include-version-information","title":"2. Include Version Information","text":"<p>For long-term compatibility, include version information:</p> <pre><code>def encode_complex_type(value):\n    return {\n        \"__mytype__\": {\n            \"version\": 1,\n            \"data\": value.serialize()\n        }\n    }\n\ndef decode_complex_type(data):\n    version = data[\"__mytype__\"][\"version\"]\n    if version == 1:\n        return MyType.deserialize(data[\"__mytype__\"][\"data\"])\n    else:\n        raise ValueError(f\"Unsupported version: {version}\")\n</code></pre>"},{"location":"pages/guide/custom-types/#3-handle-edge-cases","title":"3. Handle Edge Cases","text":"<p>Always handle None and edge cases:</p> <pre><code>def encode_custom(value):\n    if value is None:\n        return None\n    return {\"__custom__\": value.to_dict()}\n\ndef decode_custom(data):\n    if data is None:\n        return None\n    if \"__custom__\" not in data:\n        raise ValueError(\"Invalid custom data\")\n    return CustomType.from_dict(data[\"__custom__\"])\n</code></pre>"},{"location":"pages/guide/custom-types/#4-validate-input-in-decoders","title":"4. Validate Input in Decoders","text":"<pre><code>def decode_color(data: dict) -&gt; Color:\n    # Validate required fields\n    if not all(key in data for key in [\"r\", \"g\", \"b\"]):\n        raise ValueError(\"Missing required color components\")\n\n    # Validate ranges\n    r, g, b = data[\"r\"], data[\"g\"], data[\"b\"]\n    if not all(0 &lt;= c &lt;= 255 for c in [r, g, b]):\n        raise ValueError(\"Color values must be 0-255\")\n\n    return Color(r, g, b)\n</code></pre>"},{"location":"pages/guide/custom-types/#creating-reusable-type-packages","title":"Creating Reusable Type Packages","text":"<p>You can create a package of custom type handlers:</p> <pre><code># my_kajson_types.py\nimport kajson\nfrom typing import Dict, Type, Callable, Tuple\n\nclass KajsonTypeRegistry:\n    def __init__(self):\n        self.types: Dict[Type, Tuple[Callable, Callable]] = {}\n\n    def register(self, type_class: Type, encoder: Callable, decoder: Callable):\n        self.types[type_class] = (encoder, decoder)\n\n    def install(self):\n        \"\"\"Install all registered types into Kajson\"\"\"\n        for type_class, (encoder, decoder) in self.types.items():\n            kajson.UniversalJSONEncoder.register(type_class, encoder)\n            kajson.UniversalJSONDecoder.register(type_class, decoder)\n\n# Create registry\nregistry = KajsonTypeRegistry()\n\n# Add types\nfrom decimal import Decimal\nregistry.register(\n    Decimal,\n    lambda d: {\"decimal\": str(d)},\n    lambda data: Decimal(data[\"decimal\"])\n)\n\n# Usage in your app\nfrom my_kajson_types import registry\nregistry.install()\n</code></pre>"},{"location":"pages/guide/custom-types/#next-steps","title":"Next Steps","text":"<ul> <li>Explore Error Handling for robust serialization</li> <li>Check out practical Examples</li> <li>Review the API Reference for detailed documentation </li> </ul>"},{"location":"pages/guide/error-handling/","title":"Error Handling","text":"<p>Learn how to handle errors gracefully when working with Kajson, including validation errors, serialization failures, and debugging techniques.</p>"},{"location":"pages/guide/error-handling/#common-error-types","title":"Common Error Types","text":""},{"location":"pages/guide/error-handling/#jsondecodeerror","title":"JSONDecodeError","text":"<p>The standard JSON decode error when parsing invalid JSON:</p> <pre><code>import kajson\n\n# Invalid JSON syntax\ntry:\n    kajson.loads('{\"name\": \"Alice\",}')  # Trailing comma\nexcept kajson.JSONDecodeError as e:\n    print(f\"JSON syntax error: {e}\")\n    print(f\"Position: {e.pos}\")\n\n# Incomplete JSON\ntry:\n    kajson.loads('{\"name\": \"Alice\"')  # Missing closing brace\nexcept kajson.JSONDecodeError as e:\n    print(f\"Incomplete JSON: {e}\")\n</code></pre>"},{"location":"pages/guide/error-handling/#kajsondecodererror","title":"KajsonDecoderError","text":"<p>Kajson-specific errors during type reconstruction:</p> <pre><code>import kajson\nfrom pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    name: str = Field(min_length=1)\n    age: int = Field(ge=0, le=150)\n\n# Validation error\ntry:\n    invalid_json = '{\"name\": \"\", \"age\": 200, \"__class__\": \"User\", \"__module__\": \"__main__\"}'\n    user = kajson.loads(invalid_json)\nexcept kajson.KajsonDecoderError as e:\n    print(f\"Validation failed: {e}\")\n    # Access the underlying Pydantic validation error if needed\n    if hasattr(e, '__cause__'):\n        print(f\"Details: {e.__cause__}\")\n</code></pre>"},{"location":"pages/guide/error-handling/#type-registration-errors","title":"Type Registration Errors","text":"<p>Errors when working with custom type registration:</p> <pre><code>import kajson\n\n# Attempting to decode unregistered type\ntry:\n    json_str = '{\"__class__\": \"UnknownType\", \"__module__\": \"unknown\", \"data\": 123}'\n    result = kajson.loads(json_str)\nexcept kajson.KajsonDecoderError as e:\n    print(f\"Unknown type: {e}\")\n\n# Bad encoder/decoder functions\nfrom decimal import Decimal\n\ntry:\n    # This encoder returns wrong type (should return dict)\n    kajson.UniversalJSONEncoder.register(\n        Decimal,\n        lambda d: str(d)  # Wrong! Should return dict\n    )\nexcept Exception as e:\n    print(f\"Registration error: {e}\")\n</code></pre>"},{"location":"pages/guide/error-handling/#handling-pydantic-validation-errors","title":"Handling Pydantic Validation Errors","text":""},{"location":"pages/guide/error-handling/#basic-validation-handling","title":"Basic Validation Handling","text":"<pre><code>import kajson\nfrom pydantic import BaseModel, Field, ValidationError\n\nclass Product(BaseModel):\n    name: str = Field(min_length=1, max_length=50)\n    price: float = Field(gt=0)\n    stock: int = Field(ge=0)\n\ndef safe_load_product(json_str: str) -&gt; Product | None:\n    try:\n        return kajson.loads(json_str)\n    except kajson.KajsonDecoderError as e:\n        # Check if it's a Pydantic validation error\n        if isinstance(e.__cause__, ValidationError):\n            print(\"Validation errors:\")\n            for error in e.__cause__.errors():\n                print(f\"  - {error['loc']}: {error['msg']}\")\n        else:\n            print(f\"Decoder error: {e}\")\n        return None\n    except kajson.JSONDecodeError as e:\n        print(f\"Invalid JSON: {e}\")\n        return None\n\n# Test with various inputs\ntest_cases = [\n    '{\"name\": \"Laptop\", \"price\": 999.99, \"stock\": 10, \"__class__\": \"Product\", \"__module__\": \"__main__\"}',\n    '{\"name\": \"\", \"price\": 999.99, \"stock\": 10, \"__class__\": \"Product\", \"__module__\": \"__main__\"}',\n    '{\"name\": \"Laptop\", \"price\": -100, \"stock\": 10, \"__class__\": \"Product\", \"__module__\": \"__main__\"}',\n    'invalid json'\n]\n\nfor json_str in test_cases:\n    print(f\"\\nTesting: {json_str[:50]}...\")\n    product = safe_load_product(json_str)\n    if product:\n        print(f\"Success: {product.name}\")\n</code></pre>"},{"location":"pages/guide/error-handling/#collecting-all-validation-errors","title":"Collecting All Validation Errors","text":"<pre><code>import kajson\nfrom pydantic import BaseModel, Field, ValidationError\nfrom typing import List, Dict, Any\n\nclass Address(BaseModel):\n    street: str = Field(min_length=1)\n    city: str = Field(min_length=1)\n    zip_code: str = Field(pattern=r'^\\d{5}$')\n\ndef get_validation_errors(json_str: str) -&gt; Dict[str, List[str]]:\n    \"\"\"Extract all validation errors from a JSON string\"\"\"\n    errors = {}\n\n    try:\n        kajson.loads(json_str)\n    except kajson.KajsonDecoderError as e:\n        if isinstance(e.__cause__, ValidationError):\n            for error in e.__cause__.errors():\n                field = '.'.join(str(x) for x in error['loc'])\n                if field not in errors:\n                    errors[field] = []\n                errors[field].append(error['msg'])\n\n    return errors\n\n# Test with invalid data\ninvalid_address = '''{\n    \"street\": \"\",\n    \"city\": \"\",\n    \"zip_code\": \"ABC123\",\n    \"__class__\": \"Address\",\n    \"__module__\": \"__main__\"\n}'''\n\nerrors = get_validation_errors(invalid_address)\nfor field, messages in errors.items():\n    print(f\"{field}: {', '.join(messages)}\")\n</code></pre>"},{"location":"pages/guide/error-handling/#debugging-serialization-issues","title":"Debugging Serialization Issues","text":""},{"location":"pages/guide/error-handling/#debugging-complex-objects","title":"Debugging Complex Objects","text":"<pre><code>import kajson\nfrom typing import Any\nimport json\n\ndef debug_serialize(obj: Any, indent: int = 2) -&gt; str:\n    \"\"\"Serialize with detailed error information\"\"\"\n    try:\n        return kajson.dumps(obj, indent=indent)\n    except Exception as e:\n        print(f\"Serialization failed for type {type(obj)}: {e}\")\n\n        # Try to identify the problematic part\n        if hasattr(obj, '__dict__'):\n            print(\"Object attributes:\")\n            for key, value in obj.__dict__.items():\n                try:\n                    kajson.dumps(value)\n                    print(f\"  \u2713 {key}: {type(value).__name__}\")\n                except Exception as attr_e:\n                    print(f\"  \u2717 {key}: {type(value).__name__} - {attr_e}\")\n\n        raise\n\n# Example with problematic object\nclass ComplexObject:\n    def __init__(self):\n        self.name = \"Test\"\n        self.data = [1, 2, 3]\n        self.file = open(__file__, 'r')  # This will cause an error\n\ntry:\n    obj = ComplexObject()\n    json_str = debug_serialize(obj)\nexcept Exception as e:\n    print(f\"Final error: {e}\")\nfinally:\n    obj.file.close()\n</code></pre>"},{"location":"pages/guide/error-handling/#custom-error-messages","title":"Custom Error Messages","text":"<pre><code>import kajson\nfrom typing import Any\n\nclass SerializationError(Exception):\n    \"\"\"Custom error for serialization issues\"\"\"\n    def __init__(self, obj: Any, original_error: Exception):\n        self.obj = obj\n        self.original_error = original_error\n        super().__init__(\n            f\"Failed to serialize {type(obj).__name__}: {original_error}\"\n        )\n\ndef safe_dumps(obj: Any, **kwargs) -&gt; str:\n    \"\"\"Serialize with custom error handling\"\"\"\n    try:\n        return kajson.dumps(obj, **kwargs)\n    except Exception as e:\n        raise SerializationError(obj, e)\n\n# Usage\ntry:\n    result = safe_dumps({\"data\": lambda x: x})  # Lambda can't be serialized\nexcept SerializationError as e:\n    print(f\"Custom error: {e}\")\n    print(f\"Object type: {type(e.obj)}\")\n    print(f\"Original error: {e.original_error}\")\n</code></pre>"},{"location":"pages/guide/error-handling/#error-recovery-strategies","title":"Error Recovery Strategies","text":""},{"location":"pages/guide/error-handling/#fallback-values","title":"Fallback Values","text":"<pre><code>import kajson\nfrom typing import TypeVar, Type, Optional, Callable\n\nT = TypeVar('T')\n\ndef loads_with_fallback(\n    json_str: str,\n    expected_type: Type[T],\n    fallback_factory: Callable[[], T]\n) -&gt; T:\n    \"\"\"Load JSON with fallback on error\"\"\"\n    try:\n        result = kajson.loads(json_str)\n        if not isinstance(result, expected_type):\n            print(f\"Warning: Expected {expected_type}, got {type(result)}\")\n            return fallback_factory()\n        return result\n    except Exception as e:\n        print(f\"Error loading JSON: {e}\")\n        return fallback_factory()\n\n# Usage\nfrom pydantic import BaseModel\n\nclass Config(BaseModel):\n    timeout: int = 30\n    retries: int = 3\n    debug: bool = False\n\ndef default_config() -&gt; Config:\n    return Config()\n\n# Various test cases\ntest_cases = [\n    '{\"timeout\": 60, \"retries\": 5, \"debug\": true, \"__class__\": \"Config\", \"__module__\": \"__main__\"}',\n    'invalid json',\n    '{\"wrong\": \"data\"}',\n]\n\nfor json_str in test_cases:\n    config = loads_with_fallback(json_str, Config, default_config)\n    print(f\"Config: timeout={config.timeout}, retries={config.retries}\")\n</code></pre>"},{"location":"pages/guide/error-handling/#partial-recovery","title":"Partial Recovery","text":"<pre><code>import kajson\nfrom typing import Dict, Any, List\n\ndef recover_partial_data(json_str: str) -&gt; Dict[str, Any]:\n    \"\"\"Try to recover as much data as possible\"\"\"\n    try:\n        return kajson.loads(json_str)\n    except kajson.JSONDecodeError:\n        # Try to fix common issues\n        fixed = json_str\n\n        # Remove trailing commas\n        import re\n        fixed = re.sub(r',\\s*}', '}', fixed)\n        fixed = re.sub(r',\\s*]', ']', fixed)\n\n        # Try again\n        try:\n            return kajson.loads(fixed)\n        except:\n            # Last resort: try to extract key-value pairs\n            result = {}\n            pattern = r'\"(\\w+)\"\\s*:\\s*(\"(?:[^\"\\\\]|\\\\.)*\"|\\d+|true|false|null)'\n            matches = re.findall(pattern, json_str)\n            for key, value in matches:\n                try:\n                    result[key] = kajson.loads(value)\n                except:\n                    result[key] = value\n            return result\n\n# Test with malformed JSON\nmalformed = '{\"name\": \"Alice\", \"age\": 30, \"active\": true,}'\nrecovered = recover_partial_data(malformed)\nprint(f\"Recovered: {recovered}\")\n</code></pre>"},{"location":"pages/guide/error-handling/#logging-and-monitoring","title":"Logging and Monitoring","text":""},{"location":"pages/guide/error-handling/#structured-error-logging","title":"Structured Error Logging","text":"<pre><code>import kajson\nimport logging\nfrom typing import Any, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass JsonProcessor:\n    def __init__(self):\n        self.error_count = 0\n        self.success_count = 0\n\n    def process(self, json_str: str, source: str = \"unknown\") -&gt; Optional[Any]:\n        \"\"\"Process JSON with detailed logging\"\"\"\n        start_time = datetime.now()\n\n        try:\n            result = kajson.loads(json_str)\n            self.success_count += 1\n\n            logger.info(\n                \"JSON processed successfully\",\n                extra={\n                    \"source\": source,\n                    \"size\": len(json_str),\n                    \"type\": type(result).__name__,\n                    \"duration_ms\": (datetime.now() - start_time).total_seconds() * 1000\n                }\n            )\n\n            return result\n\n        except kajson.JSONDecodeError as e:\n            self.error_count += 1\n            logger.error(\n                \"JSON syntax error\",\n                extra={\n                    \"source\": source,\n                    \"error\": str(e),\n                    \"position\": e.pos if hasattr(e, 'pos') else None,\n                    \"preview\": json_str[:100] + \"...\" if len(json_str) &gt; 100 else json_str\n                }\n            )\n\n        except kajson.KajsonDecoderError as e:\n            self.error_count += 1\n            logger.error(\n                \"Type reconstruction error\",\n                extra={\n                    \"source\": source,\n                    \"error\": str(e),\n                    \"cause\": str(e.__cause__) if hasattr(e, '__cause__') else None\n                }\n            )\n\n        except Exception as e:\n            self.error_count += 1\n            logger.exception(\n                \"Unexpected error\",\n                extra={\n                    \"source\": source,\n                    \"error_type\": type(e).__name__\n                }\n            )\n\n        return None\n\n    def get_stats(self) -&gt; Dict[str, int]:\n        \"\"\"Get processing statistics\"\"\"\n        total = self.success_count + self.error_count\n        return {\n            \"total\": total,\n            \"success\": self.success_count,\n            \"errors\": self.error_count,\n            \"success_rate\": self.success_count / total if total &gt; 0 else 0\n        }\n\n# Usage\nprocessor = JsonProcessor()\n\ntest_data = [\n    ('{\"valid\": true}', \"api_response\"),\n    ('invalid json', \"user_input\"),\n    ('{\"name\": \"test\"}', \"database\"),\n]\n\nfor json_str, source in test_data:\n    processor.process(json_str, source)\n\nprint(f\"Stats: {processor.get_stats()}\")\n</code></pre>"},{"location":"pages/guide/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"pages/guide/error-handling/#1-always-handle-exceptions","title":"1. Always Handle Exceptions","text":"<pre><code>import kajson\n\ndef load_data(json_str: str) -&gt; Any:\n    \"\"\"Always wrap loads in try-except\"\"\"\n    try:\n        return kajson.loads(json_str)\n    except (kajson.JSONDecodeError, kajson.KajsonDecoderError) as e:\n        # Handle specific errors\n        logger.error(f\"Failed to load JSON: {e}\")\n        raise\n    except Exception as e:\n        # Catch unexpected errors\n        logger.exception(\"Unexpected error in JSON loading\")\n        raise\n</code></pre>"},{"location":"pages/guide/error-handling/#2-provide-context-in-errors","title":"2. Provide Context in Errors","text":"<pre><code>class DataLoadError(Exception):\n    \"\"\"Custom error with context\"\"\"\n    def __init__(self, filename: str, line_num: int, original_error: Exception):\n        super().__init__(\n            f\"Failed to load data from {filename}, line {line_num}: {original_error}\"\n        )\n        self.filename = filename\n        self.line_num = line_num\n        self.original_error = original_error\n</code></pre>"},{"location":"pages/guide/error-handling/#3-validate-before-serializing","title":"3. Validate Before Serializing","text":"<pre><code>def safe_serialize(obj: Any) -&gt; Optional[str]:\n    \"\"\"Validate object before serialization\"\"\"\n    # Check for known problematic types\n    if hasattr(obj, '__call__'):\n        logger.warning(f\"Cannot serialize callable: {obj}\")\n        return None\n\n    try:\n        return kajson.dumps(obj)\n    except Exception as e:\n        logger.error(f\"Serialization failed: {e}\")\n        return None\n</code></pre>"},{"location":"pages/guide/error-handling/#next-steps","title":"Next Steps","text":"<ul> <li>Review practical Examples for real-world error handling</li> <li>Check the API Reference for detailed error specifications</li> <li>Learn about Custom Types to avoid serialization errors </li> </ul>"},{"location":"pages/guide/overview/","title":"User Guide Overview","text":"<p>Welcome to the Kajson User Guide! This comprehensive guide will help you master all aspects of Kajson, from basic usage to advanced features.</p>"},{"location":"pages/guide/overview/#what-youll-learn","title":"What You'll Learn","text":"<p>This guide is organized into several sections, each focusing on different aspects of Kajson:</p>"},{"location":"pages/guide/overview/#basic-usage","title":"Basic Usage","text":"<p>Learn the fundamentals of using Kajson as a drop-in replacement for Python's standard json module. Covers:</p> <ul> <li>Basic serialization and deserialization</li> <li>Working with files</li> <li>Formatting options</li> <li>Common patterns</li> </ul>"},{"location":"pages/guide/overview/#pydantic-integration","title":"Pydantic Integration","text":"<p>Discover how Kajson seamlessly integrates with Pydantic v2 models:</p> <ul> <li>Automatic model serialization</li> <li>Validation during deserialization</li> <li>Nested model support</li> <li>Advanced Pydantic features</li> </ul>"},{"location":"pages/guide/overview/#custom-types","title":"Custom Types","text":"<p>Learn how to extend Kajson to support your own custom types:</p> <ul> <li>Registering custom encoders/decoders</li> <li>Using the <code>__json_encode__</code> and <code>__json_decode__</code> hooks</li> <li>Best practices for custom type support</li> <li>Common patterns and examples</li> </ul>"},{"location":"pages/guide/overview/#error-handling","title":"Error Handling","text":"<p>Understand how to handle errors and edge cases:</p> <ul> <li>Common error scenarios</li> <li>Validation errors with Pydantic</li> <li>Debugging serialization issues</li> <li>Best practices for robust code</li> </ul>"},{"location":"pages/guide/overview/#key-concepts","title":"Key Concepts","text":""},{"location":"pages/guide/overview/#type-preservation","title":"Type Preservation","text":"<p>Kajson's main innovation is automatic type preservation. When you serialize an object, Kajson adds metadata that allows perfect reconstruction:</p> <pre><code>from datetime import datetime\nimport kajson\n\n# Original object\ndata = {\"created\": datetime.now(), \"count\": 42}\n\n# Serialize\njson_str = kajson.dumps(data)\n\n# Deserialize - types are preserved!\nrestored = kajson.loads(json_str)\nassert isinstance(restored[\"created\"], datetime)\n</code></pre>"},{"location":"pages/guide/overview/#drop-in-replacement","title":"Drop-in Replacement","text":"<p>Kajson is designed to be a drop-in replacement for the standard <code>json</code> module:</p> <pre><code># Change this:\nimport json\n\n# To this:\nimport kajson as json\n\n# All your existing code continues to work!\n</code></pre>"},{"location":"pages/guide/overview/#extensibility","title":"Extensibility","text":"<p>Kajson is built to be extensible. You can easily add support for any type:</p> <pre><code>import kajson\nfrom decimal import Decimal\n\n# Register Decimal support\nkajson.UniversalJSONEncoder.register(\n    Decimal,\n    lambda d: {\"value\": str(d)}\n)\nkajson.UniversalJSONDecoder.register(\n    Decimal,\n    lambda data: Decimal(data[\"value\"])\n)\n</code></pre>"},{"location":"pages/guide/overview/#best-practices","title":"Best Practices","text":"<ol> <li>Use Type Hints: Always use type hints in your Pydantic models for better IDE support and documentation</li> <li>Handle Errors: Always wrap deserialization in try-except blocks when dealing with untrusted data</li> <li>Test Serialization: Test that your objects can round-trip (serialize and deserialize) correctly</li> <li>Keep It Simple: Start with built-in support before creating custom encoders</li> </ol>"},{"location":"pages/guide/overview/#getting-help","title":"Getting Help","text":"<ul> <li>Check the API Reference for detailed function documentation</li> <li>Browse Examples for real-world use cases</li> <li>Visit our GitHub repository for issues and discussions</li> </ul>"},{"location":"pages/guide/overview/#next-steps","title":"Next Steps","text":"<p>Ready to dive in? Start with Basic Usage to learn the fundamentals! </p>"},{"location":"pages/guide/pydantic/","title":"Pydantic Integration","text":"<p>Kajson provides seamless integration with Pydantic v2 models, automatically handling serialization and deserialization while preserving validation and type safety.</p>"},{"location":"pages/guide/pydantic/#basic-pydantic-model-serialization","title":"Basic Pydantic Model Serialization","text":""},{"location":"pages/guide/pydantic/#simple-models","title":"Simple Models","text":"<pre><code>from pydantic import BaseModel\nimport kajson\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n    is_active: bool = True\n\n# Create instance\nuser = User(id=1, name=\"Alice\", email=\"alice@example.com\")\n\n# Serialize to JSON\njson_str = kajson.dumps(user, indent=2)\nprint(json_str)\n\n# Deserialize back to User instance\nrestored_user = kajson.loads(json_str)\nassert isinstance(restored_user, User)\nassert user == restored_user\n</code></pre>"},{"location":"pages/guide/pydantic/#models-with-datetime-fields","title":"Models with DateTime Fields","text":"<pre><code>from datetime import datetime\nfrom pydantic import BaseModel\nimport kajson\n\nclass Event(BaseModel):\n    title: str\n    start_time: datetime\n    end_time: datetime\n    description: str | None = None\n\n# Create event\nevent = Event(\n    title=\"Team Meeting\",\n    start_time=datetime(2025, 1, 15, 10, 0),\n    end_time=datetime(2025, 1, 15, 11, 30)\n)\n\n# Serialize and deserialize\njson_str = kajson.dumps(event)\nrestored = kajson.loads(json_str)\n\n# DateTime objects are preserved\nassert isinstance(restored.start_time, datetime)\n</code></pre>"},{"location":"pages/guide/pydantic/#nested-models","title":"Nested Models","text":""},{"location":"pages/guide/pydantic/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<pre><code>from typing import List\nfrom datetime import datetime\nfrom pydantic import BaseModel\nimport kajson\n\nclass Comment(BaseModel):\n    id: int\n    author: str\n    content: str\n    created_at: datetime\n\nclass BlogPost(BaseModel):\n    id: int\n    title: str\n    content: str\n    author: str\n    created_at: datetime\n    comments: List[Comment]\n\n# Create nested structure\npost = BlogPost(\n    id=1,\n    title=\"Understanding Kajson\",\n    content=\"Kajson makes working with Pydantic models easy...\",\n    author=\"Alice\",\n    created_at=datetime.now(),\n    comments=[\n        Comment(id=1, author=\"Bob\", content=\"Great post!\", created_at=datetime.now()),\n        Comment(id=2, author=\"Carol\", content=\"Very helpful\", created_at=datetime.now())\n    ]\n)\n\n# Serialize and deserialize\njson_str = kajson.dumps(post)\nrestored = kajson.loads(json_str)\n\n# All nested models are properly restored\nassert isinstance(restored, BlogPost)\nassert all(isinstance(comment, Comment) for comment in restored.comments)\n</code></pre>"},{"location":"pages/guide/pydantic/#complex-nested-structures","title":"Complex Nested Structures","text":"<pre><code>from typing import List, Dict, Optional\nfrom pydantic import BaseModel\nimport kajson\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    country: str\n    postal_code: str\n\nclass Company(BaseModel):\n    name: str\n    address: Address\n\nclass Person(BaseModel):\n    name: str\n    age: int\n    addresses: Dict[str, Address]\n    employer: Optional[Company] = None\n\n# Create complex nested structure\nperson = Person(\n    name=\"Alice\",\n    age=30,\n    addresses={\n        \"home\": Address(\n            street=\"123 Main St\",\n            city=\"New York\",\n            country=\"USA\",\n            postal_code=\"10001\"\n        ),\n        \"work\": Address(\n            street=\"456 Business Ave\",\n            city=\"New York\",\n            country=\"USA\",\n            postal_code=\"10002\"\n        )\n    },\n    employer=Company(\n        name=\"Tech Corp\",\n        address=Address(\n            street=\"789 Tech Blvd\",\n            city=\"San Francisco\",\n            country=\"USA\",\n            postal_code=\"94105\"\n        )\n    )\n)\n\n# Perfect serialization and deserialization\njson_str = kajson.dumps(person)\nrestored = kajson.loads(json_str)\n</code></pre>"},{"location":"pages/guide/pydantic/#pydantic-validation","title":"Pydantic Validation","text":""},{"location":"pages/guide/pydantic/#validation-during-deserialization","title":"Validation During Deserialization","text":"<pre><code>from pydantic import BaseModel, Field, validator\nimport kajson\n\nclass Product(BaseModel):\n    name: str = Field(min_length=1, max_length=100)\n    price: float = Field(gt=0, description=\"Price must be positive\")\n    quantity: int = Field(ge=0, default=0)\n\n    @validator('name')\n    def name_must_be_capitalized(cls, v):\n        if not v[0].isupper():\n            raise ValueError('Product name must start with capital letter')\n        return v\n\n# Valid product\nvalid_json = '{\"name\": \"Laptop\", \"price\": 999.99, \"quantity\": 10, \"__class__\": \"Product\", \"__module__\": \"__main__\"}'\nproduct = kajson.loads(valid_json)\nprint(f\"Valid product: {product.name}\")\n\n# Invalid product - will raise validation error\ntry:\n    invalid_json = '{\"name\": \"laptop\", \"price\": -100, \"__class__\": \"Product\", \"__module__\": \"__main__\"}'\n    kajson.loads(invalid_json)\nexcept kajson.KajsonDecoderError as e:\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"pages/guide/pydantic/#custom-validators","title":"Custom Validators","text":"<pre><code>from pydantic import BaseModel, field_validator\nfrom datetime import date\nimport kajson\n\nclass Person(BaseModel):\n    name: str\n    birth_date: date\n\n    @field_validator('birth_date')\n    def validate_age(cls, v):\n        today = date.today()\n        age = today.year - v.year - ((today.month, today.day) &lt; (v.month, v.day))\n        if age &lt; 18:\n            raise ValueError('Person must be at least 18 years old')\n        return v\n\n# Create and serialize\nperson = Person(name=\"Alice\", birth_date=date(1990, 1, 1))\njson_str = kajson.dumps(person)\n\n# Validation happens on deserialization\nrestored = kajson.loads(json_str)\n</code></pre>"},{"location":"pages/guide/pydantic/#advanced-pydantic-features","title":"Advanced Pydantic Features","text":""},{"location":"pages/guide/pydantic/#model-config","title":"Model Config","text":"<pre><code>from pydantic import BaseModel, ConfigDict\nimport kajson\n\nclass User(BaseModel):\n    model_config = ConfigDict(\n        str_strip_whitespace=True,\n        str_to_lower=True,\n        validate_assignment=True\n    )\n\n    username: str\n    email: str\n\n# Pydantic config is respected\nuser = User(username=\"  ALICE  \", email=\"  ALICE@EXAMPLE.COM  \")\nprint(user.username)  # \"alice\"\nprint(user.email)     # \"alice@example.com\"\n\n# Serialize and deserialize\njson_str = kajson.dumps(user)\nrestored = kajson.loads(json_str)\n</code></pre>"},{"location":"pages/guide/pydantic/#union-types-and-discriminated-unions","title":"Union Types and Discriminated Unions","text":"<pre><code>from typing import Union, Literal\nfrom pydantic import BaseModel, Field\nimport kajson\n\nclass Cat(BaseModel):\n    pet_type: Literal[\"cat\"]\n    meows: int\n\nclass Dog(BaseModel):\n    pet_type: Literal[\"dog\"] \n    barks: int\n\nclass Bird(BaseModel):\n    pet_type: Literal[\"bird\"]\n    chirps: int\n\nPet = Union[Cat, Dog, Bird]\n\nclass Person(BaseModel):\n    name: str\n    pet: Pet = Field(discriminator='pet_type')\n\n# Create person with different pets\npeople = [\n    Person(name=\"Alice\", pet=Cat(pet_type=\"cat\", meows=10)),\n    Person(name=\"Bob\", pet=Dog(pet_type=\"dog\", barks=5)),\n    Person(name=\"Carol\", pet=Bird(pet_type=\"bird\", chirps=20))\n]\n\n# Serialize list\njson_str = kajson.dumps(people)\n\n# Deserialize - correct types are restored\nrestored = kajson.loads(json_str)\nassert isinstance(restored[0].pet, Cat)\nassert isinstance(restored[1].pet, Dog)\nassert isinstance(restored[2].pet, Bird)\n</code></pre>"},{"location":"pages/guide/pydantic/#generic-models","title":"Generic Models","text":"<pre><code>from typing import TypeVar, Generic, List\nfrom pydantic import BaseModel\nimport kajson\n\nT = TypeVar('T')\n\nclass PagedResponse(BaseModel, Generic[T]):\n    items: List[T]\n    page: int\n    page_size: int\n    total: int\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n# Create paged response\nusers = [User(id=i, name=f\"User{i}\") for i in range(1, 6)]\nresponse = PagedResponse[User](\n    items=users,\n    page=1,\n    page_size=5,\n    total=100\n)\n\n# Serialize and deserialize\njson_str = kajson.dumps(response)\nrestored = kajson.loads(json_str)\n\n# Generic type information is preserved\nassert all(isinstance(user, User) for user in restored.items)\n</code></pre>"},{"location":"pages/guide/pydantic/#working-with-lists-and-dicts-of-models","title":"Working with Lists and Dicts of Models","text":"<pre><code>from typing import List, Dict\nfrom pydantic import BaseModel\nimport kajson\n\nclass Task(BaseModel):\n    id: int\n    title: str\n    completed: bool = False\n\n# List of models\ntasks = [\n    Task(id=1, title=\"Write documentation\"),\n    Task(id=2, title=\"Review PR\", completed=True),\n    Task(id=3, title=\"Deploy to production\")\n]\n\n# Dict of models\ntask_dict = {\n    \"urgent\": Task(id=4, title=\"Fix critical bug\"),\n    \"normal\": Task(id=5, title=\"Add new feature\"),\n    \"low\": Task(id=6, title=\"Update dependencies\")\n}\n\n# Both serialize perfectly\ntasks_json = kajson.dumps(tasks)\ndict_json = kajson.dumps(task_dict)\n\n# And deserialize with correct types\nrestored_tasks = kajson.loads(tasks_json)\nrestored_dict = kajson.loads(dict_json)\n\nassert all(isinstance(task, Task) for task in restored_tasks)\nassert all(isinstance(task, Task) for task in restored_dict.values())\n</code></pre>"},{"location":"pages/guide/pydantic/#best-practices","title":"Best Practices","text":""},{"location":"pages/guide/pydantic/#1-use-type-annotations","title":"1. Use Type Annotations","text":"<p>Always use proper type annotations for better IDE support and validation:</p> <pre><code>from typing import Optional, List\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    name: str  # Required\n    email: Optional[str] = None  # Optional with None default\n    tags: List[str] = []  # List with empty default\n</code></pre>"},{"location":"pages/guide/pydantic/#2-handle-validation-errors","title":"2. Handle Validation Errors","text":"<p>Always handle potential validation errors when deserializing untrusted data:</p> <pre><code>try:\n    user = kajson.loads(untrusted_json)\nexcept kajson.KajsonDecoderError as e:\n    # Log error, return error response, etc.\n    print(f\"Invalid data: {e}\")\n</code></pre>"},{"location":"pages/guide/pydantic/#3-use-field-descriptions","title":"3. Use Field Descriptions","text":"<p>Document your models for better API documentation:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(description=\"Product name\", example=\"Laptop\")\n    price: float = Field(description=\"Price in USD\", gt=0, example=999.99)\n    in_stock: bool = Field(description=\"Whether product is available\", default=True)\n</code></pre>"},{"location":"pages/guide/pydantic/#4-separate-dtos-from-domain-models","title":"4. Separate DTOs from Domain Models","text":"<p>Consider using separate Pydantic models for data transfer:</p> <pre><code># Domain model\nclass User:\n    def __init__(self, id: int, name: str, password_hash: str):\n        self.id = id\n        self.name = name\n        self._password_hash = password_hash\n\n# DTO for serialization\nclass UserDTO(BaseModel):\n    id: int\n    name: str\n    # Note: no password field\n\n    @classmethod\n    def from_domain(cls, user: User) -&gt; \"UserDTO\":\n        return cls(id=user.id, name=user.name)\n</code></pre>"},{"location":"pages/guide/pydantic/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Custom Types to extend Kajson further</li> <li>Explore Error Handling for robust applications</li> <li>Check out Examples for real-world use cases </li> </ul>"}]}